<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Data Explorer User Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Embedded user guide for the UK Air Pollution/Emissions Data Explorer">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../SharedResources/common-styles.css?v=inter1">
  <style>
    :root {
      --user-guide-buffer: 14px;
      --user-guide-gap: 20px;
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #ffffff;
      color: #0f172a;
      margin: 0;
    }

    .user-guide-shell {
      padding-bottom: 0;
      margin: 0;
    }

    .user-guide-downloads {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 0 0 20px 0;
      padding-left: 0;
      align-items: flex-start;
    }

    .user-guide-download {
      color: #ff8c1a;
      font-weight: 600;
      text-decoration: none;
      font-size: 23px;
      display: inline-flex;
      align-items: center;
      padding: 5px 10px;
      border-radius: 8px;
      line-height: 1.3;
      align-self: flex-start;
    }

    .user-guide-download:hover,
    .user-guide-download:focus-visible {
      color: #cc6c00;
    }

    .user-guide-title {
      font-weight: 700 !important;
      letter-spacing: 0;
    }

    .chart-wrapper.user-guide-wrapper {
      width: calc(100% - 140px);
      margin: 0 auto 0 0;
      border: none;
      box-shadow: none;
      padding: 0;
      background: transparent;
      min-height: 480px;
    }

    .user-guide-viewer {
      position: relative;
      width: 100%;
      min-height: 480px;
      background: transparent;
    }

    .user-guide-pages {
      display: flex;
      gap: var(--user-guide-gap);
      justify-content: center;
      align-items: flex-start;
      min-height: 460px;
      padding: 16px 0 8px;
    }

    .guide-page {
      position: relative;
      flex: 0 0 auto;
      background: #ffffff;
      border-radius: 14px;
      box-shadow: none;
      filter: drop-shadow(0 26px 32px rgba(15, 23, 42, 0.24));
      overflow: hidden;
      min-width: 200px;
    }

    .guide-page canvas {
      display: block;
      width: 100%;
      height: auto;
      background: #fff;
    }

    .text-layer,
    .annotation-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    .text-layer {
      font-family: 'Source Sans Pro', 'IBM Plex Sans', 'Inter', system-ui, sans-serif;
      line-height: 1;
      transform-origin: 0 0;
      overflow: hidden;
      user-select: text;
      pointer-events: auto;
    }

    .text-layer span {
      position: absolute;
      white-space: pre;
      transform-origin: 0 0;
      color: transparent;
      cursor: text;
    }

    .text-layer span::selection {
      background: rgba(255, 140, 26, 0.35);
      color: transparent;
    }

    .text-layer .highlight {
      background: rgba(255, 140, 26, 0.35);
      border-radius: 2px;
    }

    .text-layer .highlight.selected {
      background: rgba(255, 140, 26, 0.55);
    }

    .text-layer .endOfContent {
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      width: 0;
      height: 0;
      z-index: -1;
    }

    .annotation-layer {
      z-index: 2;
    }

    .annotation-layer a {
      position: absolute;
      display: block;
      pointer-events: auto;
      border-radius: 3px;
      text-decoration: none;
    }

    .annotation-layer a:focus-visible {
      outline: 2px solid rgba(255, 140, 26, 0.8);
      outline-offset: 2px;
    }

    .spread-nav {
      position: absolute;
      top: var(--nav-vertical-center, 50%);
      transform: translateY(-50%);
      width: 56px;
      height: 86px;
      border-radius: 10px;
      border: none;
      background: rgba(0, 0, 0, 0.45);
      color: #fff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 5;
      transition: background 160ms ease, transform 160ms ease;
      box-shadow: 0 18px 36px rgba(15, 23, 42, 0.28);
      pointer-events: auto;
    }

    .spread-nav span {
      font-size: 2.8rem;
      line-height: 1;
      font-weight: 600;
      letter-spacing: -0.05em;
    }

    .spread-nav:hover:not(:disabled),
    .spread-nav:focus-visible {
      background: rgba(0, 0, 0, 0.65);
      transform: translateY(-50%) scale(1.03);
      outline: none;
    }

    .spread-nav:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }

    .spread-nav.is-hidden {
      visibility: hidden;
      opacity: 0;
    }

    .spread-nav--prev {
      left: var(--nav-offset-prev, var(--nav-offset, 10px));
    }

    .spread-nav--next {
      right: var(--nav-offset-next, var(--nav-offset, 10px));
    }

    .user-guide-status {
      margin: 0 0 6px;
    }

    .user-guide-status.is-hidden {
      display: none;
    }

    .user-guide-hint {
      margin: 0;
      font-size: 0.95rem;
      color: #475569;
    }

    .user-guide-placeholder {
      margin: 0;
      color: #94a3b8;
    }

    @media (max-width: 900px) {
      .chart-wrapper.user-guide-wrapper {
        width: 100%;
      }

      .user-guide-viewer {
        min-height: 420px;
      }
    }

    @media (max-width: 640px) {
      .chart-shell {
        padding: 18px 18px 30px;
      }

      .main-title {
        font-size: 26px;
      }
    }
  </style>
</head>
<body data-page-slug="user-guide">
  <div class="chart-shell user-guide-shell">
    <div id="mainContent">
      <div class="title-row">
        <h2 class="main-title user-guide-title" style="font-weight: 700;">
          <span class="title-part title-part-1">User</span>
          <span class="title-part title-part-2">Guide</span>
        </h2>
      </div>

      <div class="user-guide-downloads" role="group" aria-label="User guide downloads">
        <a id="downloadUserGuide" class="user-guide-download" href="../SharedResources/docs/User-Guide-Pollution-Emissions-Data-Explorer-v1.0.pdf" download target="_blank" rel="noopener">Download User Guide</a>
      </div>

      <div class="user-guide-status">
        <p class="user-guide-hint" id="pageLabel" aria-live="polite">Loading user guide&hellip;</p>
      </div>

      <div class="chart-wrapper user-guide-wrapper" role="region" aria-label="User guide spread">
        <div class="user-guide-viewer" id="guideViewer">
          <button class="spread-nav spread-nav--prev" type="button" id="spreadPrev" aria-label="Previous pages" disabled>
            <span aria-hidden="true">&#10094;</span>
          </button>
          <div class="user-guide-pages" id="pageSpread" role="group" aria-live="polite" aria-label="User guide pages">
            <p class="user-guide-placeholder">Loading user guide&hellip;</p>
          </div>
          <button class="spread-nav spread-nav--next" type="button" id="spreadNext" aria-label="Next pages" disabled>
            <span aria-hidden="true">&#10095;</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    (async () => {
      const scriptUrl = new URL(import.meta.url || window.location.href);
      const pdfModuleUrl = new URL('../SharedResources/pdfjs/build/pdf.mjs', scriptUrl);
      const workerModuleUrl = new URL('../SharedResources/pdfjs/build/pdf.worker.mjs', scriptUrl);
      const pdfjsLib = await import(pdfModuleUrl.href);
      const renderTextLayerFn = typeof pdfjsLib.renderTextLayer === 'function' ? pdfjsLib.renderTextLayer : null;
      const TextLayerClass = typeof pdfjsLib.TextLayer === 'function' ? pdfjsLib.TextLayer : null;
      const worker = new Worker(workerModuleUrl.href, { type: 'module' });
      pdfjsLib.GlobalWorkerOptions.workerPort = worker;

      const basePdfPath = '../SharedResources/docs/User-Guide-Pollution-Emissions-Data-Explorer-v1.0.pdf';
      const tutorialPdfPath = '../SharedResources/docs/Bubble-Chart-Tutorial-v4.pdf';
      const shell = document.querySelector('.chart-shell');
      const wrapper = document.querySelector('.user-guide-wrapper');
      const viewer = document.getElementById('guideViewer');
      const spread = document.getElementById('pageSpread');
      const pageLabel = document.getElementById('pageLabel');
      const prevBtn = document.getElementById('spreadPrev');
      const nextBtn = document.getElementById('spreadNext');
      const downloadGuideLink = document.getElementById('downloadUserGuide');
      const downloadTutorialLink = document.getElementById('downloadTutorial');
      const dualViewQuery = window.matchMedia('(min-width: 1100px)');
      const ALWAYS_SINGLE_VIEW = true;
      const MIN_FRAME_HEIGHT = 460;
      const WRAPPER_BUFFER = 10;
      const MAX_PAGE_WIDTH = 1280;
      const MIN_PAGE_WIDTH = 260;
      const TARGET_PAGE_WIDTH = 920;
      const DEFAULT_PAGE_ASPECT_RATIO = Math.SQRT2; // height / width fallback (A4 portrait)
      const FOOTER_VIEWPORT_GAP = 6;
      const GUIDE_VERTICAL_GAP = 4;
      const FOOTER_CLAMP_BUFFER = 8;
      const FOOTER_SHADOW_OVERHANG = 18;
      const SOCIAL_SIDEBAR_RESERVE = 140;

      let pdfDoc = null;
      let currentPage = 1;
      let renderVersion = 0;
      let documentAspectRatio = DEFAULT_PAGE_ASPECT_RATIO;
      let parentViewportHeight = null;
      let parentFooterHeight = 0;
      let heightTimer = null;

      const keyTargets = new Set(['INPUT', 'TEXTAREA', 'SELECT']);

      function initializeViewer() {
        hydrateDownloadLinks();
        loadPdfDocument();
        applyWrapperHeight();
        scheduleHeightUpdate(120);
        requestParentMetrics();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeViewer, { once: true });
      } else {
        initializeViewer();
      }

    prevBtn?.addEventListener('click', goToPrevious);
    nextBtn?.addEventListener('click', goToNext);

    const handleSpreadModeChange = () => {
      normalizeCurrentPage();
      renderSpread();
    };

    if (typeof dualViewQuery.addEventListener === 'function') {
      dualViewQuery.addEventListener('change', handleSpreadModeChange);
    } else if (typeof dualViewQuery.addListener === 'function') {
      dualViewQuery.addListener(handleSpreadModeChange);
    }

    window.addEventListener('resize', () => {
      if (pdfDoc) {
        renderSpread();
      }
      if (!parentViewportHeight) {
        scheduleHeightUpdate(90);
      }
    });

    window.addEventListener('keydown', event => {
      if (event.defaultPrevented) {
        return;
      }
      if (event.metaKey || event.ctrlKey || event.altKey) {
        return;
      }
      const tagName = event.target?.tagName;
      if (tagName && keyTargets.has(tagName.toUpperCase())) {
        return;
      }
      if (event.key === 'ArrowLeft') {
        event.preventDefault();
        goToPrevious();
      } else if (event.key === 'ArrowRight') {
        event.preventDefault();
        goToNext();
      }
    });

    window.addEventListener('message', event => {
      const payload = event?.data;
      if (!payload) {
        return;
      }

      if (payload.type === 'requestHeight') {
        scheduleHeightUpdate(40);
        return;
      }

      if (payload.type === 'parentViewportMetrics') {
        updateViewportMetrics(payload);
        return;
      }

      if (payload.type === 'parentFooterHeight' && Number.isFinite(payload.value)) {
        parentFooterHeight = payload.value;
        applyWrapperHeight();
        scheduleHeightUpdate(40);
      }
    });

    function hydrateDownloadLinks() {
      if (downloadGuideLink) {
        downloadGuideLink.href = buildAbsoluteUrl(basePdfPath);
      }
      if (downloadTutorialLink) {
        downloadTutorialLink.href = buildAbsoluteUrl(tutorialPdfPath);
      }
    }

    function buildAbsoluteUrl(relativePath) {
      try {
        return new URL(relativePath, window.location.href).href;
      } catch (error) {
        console.warn('Unable to build absolute URL for user guide resource', error);
        return relativePath;
      }
    }

    async function loadPdfDocument() {
      setStatus('Loading user guideâ€¦');
      hideNavButton(prevBtn, true);
      hideNavButton(nextBtn, true);
      try {
        const url = buildAbsoluteUrl(basePdfPath);
        const task = pdfjsLib.getDocument({ url });
        pdfDoc = await task.promise;
        await updateDocumentAspectRatio();
        scheduleHeightUpdate(80);
        currentPage = 1;
        renderSpread();
      } catch (error) {
        console.error('Unable to load user guide PDF', error);
        setStatus('Unable to load user guide');
        spread.innerHTML = '<p class="user-guide-placeholder">Unable to load the user guide. Please download it instead.</p>';
        scheduleHeightUpdate(60);
      }
    }

    function dualViewActive() {
      if (ALWAYS_SINGLE_VIEW) {
        return false;
      }
      return dualViewQuery.matches;
    }

    function normalizeCurrentPage() {
      if (!pdfDoc) {
        currentPage = 1;
        return;
      }
      currentPage = Math.min(Math.max(1, currentPage), pdfDoc.numPages);
    }

    async function renderSpread() {
      if (!pdfDoc || !viewer || !spread) {
        return;
      }
      normalizeCurrentPage();
      const visiblePages = getVisiblePages();
      if (!visiblePages.length) {
        return;
      }
      currentPage = visiblePages[0];
      renderVersion += 1;
      const token = renderVersion;
      const stagedContainers = [];
      const containerMap = new Map();
      visiblePages.forEach(pageNumber => {
        const container = createPageContainer(pageNumber);
        containerMap.set(pageNumber, container);
        stagedContainers.push(container);
      });
      updateNavState(visiblePages);

      const pageDimensions = getPageDimensions(visiblePages.length);
      const releaseHeightLock = lockSpreadHeight();

      try {
        for (const pageNumber of visiblePages) {
          if (token !== renderVersion) {
            releaseHeightLock();
            return;
          }
          const container = containerMap.get(pageNumber);
          await renderPage(pageNumber, container, pageDimensions, token);
          if (token !== renderVersion) {
            releaseHeightLock();
            return;
          }
        }

        spread.replaceChildren(...stagedContainers);
        releaseHeightLock();
        updateNavOffset();
        setStatus('');
        scheduleHeightUpdate(60);
      } catch (error) {
        releaseHeightLock();
        console.warn('Unable to complete spread render', error);
      }
    }

    function getVisiblePages() {
      if (!pdfDoc) {
        return [];
      }
      if (!dualViewActive()) {
        return [Math.min(currentPage, pdfDoc.numPages)];
      }
      const focusPage = Math.min(Math.max(1, currentPage), pdfDoc.numPages);
      const pages = new Set([focusPage]);
      let partner = focusPage + 1;
      if (partner > pdfDoc.numPages && pdfDoc.numPages > 1) {
        partner = focusPage - 1;
      }
      if (partner >= 1 && partner <= pdfDoc.numPages && partner !== focusPage) {
        pages.add(partner);
      }
      return Array.from(pages).sort((a, b) => a - b);
    }

    function createPageContainer(pageNumber) {
      const wrapperEl = document.createElement('div');
      wrapperEl.className = 'guide-page';
      wrapperEl.dataset.page = String(pageNumber);
      const canvas = document.createElement('canvas');
      const textLayer = document.createElement('div');
      textLayer.className = 'text-layer';
      const annotationLayer = document.createElement('div');
      annotationLayer.className = 'annotation-layer';
      wrapperEl.append(canvas, textLayer, annotationLayer);
      return wrapperEl;
    }

    function getShellViewportReserve() {
      if (!shell) {
        return GUIDE_VERTICAL_GAP + WRAPPER_BUFFER;
      }
      try {
        const styles = window.getComputedStyle(shell);
        const paddingTop = parseFloat(styles.paddingTop) || 0;
        const paddingBottom = parseFloat(styles.paddingBottom) || 0;
        return Math.round(paddingTop + paddingBottom + GUIDE_VERTICAL_GAP);
      } catch (error) {
        return GUIDE_VERTICAL_GAP + WRAPPER_BUFFER;
      }
    }

    function getPageDimensions(pageCount) {
      const aspectRatio = getCurrentAspectRatio();
      if (!viewer) {
        const fallbackWidth = MAX_PAGE_WIDTH;
        return { width: fallbackWidth, height: Math.round(fallbackWidth * aspectRatio) };
      }
      const available = viewer.clientWidth || spread.clientWidth || window.innerWidth || 960;
      const style = window.getComputedStyle(spread);
      const gapValue = pageCount > 1 ? parseFloat(style.gap || '0') || 0 : 0;
      const effectiveWidth = available - gapValue * Math.max(0, pageCount - 1);
      const rawWidthPerPage = effectiveWidth / Math.max(1, pageCount);
      const widthPerPage = Number.isFinite(rawWidthPerPage) && rawWidthPerPage > 0 ? rawWidthPerPage : MAX_PAGE_WIDTH;
      const referenceHeight = getReferenceViewportHeight();

      if (pageCount === 1) {
        const viewportWidth = window.innerWidth || document.documentElement?.clientWidth || available;
        const maxSocialAdjustedWidth = viewportWidth - Math.max(0, SOCIAL_SIDEBAR_RESERVE);
        const widthBudget = Math.min(widthPerPage, maxSocialAdjustedWidth);
        const preferredWidth = Math.min(TARGET_PAGE_WIDTH, widthBudget);
        const clampedWidth = Math.max(MIN_PAGE_WIDTH, Math.min(MAX_PAGE_WIDTH, preferredWidth));
        const derivedHeight = Math.round(clampedWidth * aspectRatio);
        const finalHeight = Math.max(derivedHeight, MIN_FRAME_HEIGHT);
        return { width: clampedWidth, height: finalHeight };
      }

      const heightLimitedWidth = referenceHeight > 0 ? (referenceHeight / aspectRatio) : MAX_PAGE_WIDTH;
      const clampedWidth = Math.min(
        MAX_PAGE_WIDTH,
        Math.max(MIN_PAGE_WIDTH, Math.min(widthPerPage, heightLimitedWidth))
      );
      const derivedHeight = Math.round(clampedWidth * aspectRatio);
      return { width: clampedWidth, height: derivedHeight };
    }

    async function renderPage(pageNumber, container, pageDimensions, token) {
      if (!pdfDoc || !container) {
        return;
      }
      const targetWidth = pageDimensions?.width || MAX_PAGE_WIDTH;
      const targetHeight = pageDimensions?.height || Math.round(targetWidth * getCurrentAspectRatio());
      const canvas = container.querySelector('canvas');
      const textLayer = container.querySelector('.text-layer');
      const annotationLayer = container.querySelector('.annotation-layer');
      if (!canvas || !textLayer || !annotationLayer) {
        return;
      }
      textLayer.innerHTML = '';
      annotationLayer.innerHTML = '';

      try {
        const page = await pdfDoc.getPage(pageNumber);
        const initialViewport = page.getViewport({ scale: 1 });
        const scale = targetWidth / initialViewport.width;
        const viewport = page.getViewport({ scale });
        container.style.width = `${viewport.width}px`;
        container.style.height = `${targetHeight}px`;

        const outputScale = window.devicePixelRatio || 1;
        const context = canvas.getContext('2d', { alpha: false });
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = `${viewport.width}px`;
        canvas.style.height = `${viewport.height}px`;
        context.setTransform(outputScale, 0, 0, outputScale, 0, 0);
        context.clearRect(0, 0, canvas.width, canvas.height);

        await page.render({ canvasContext: context, viewport }).promise;
        if (token !== renderVersion) {
          return;
        }

        const textContent = await page.getTextContent();
        textLayer.style.width = `${viewport.width}px`;
        textLayer.style.height = `${viewport.height}px`;

        await renderTextLayerContent({ textContent, textLayer, viewport });

        if (token !== renderVersion) {
          return;
        }

        const annotations = await page.getAnnotations({ intent: 'display' });
        renderAnnotations(annotationLayer, annotations, viewport);
      } catch (error) {
        console.warn('Unable to render page', pageNumber, error);
      }
    }

    function renderAnnotations(container, annotations, viewport) {
      container.innerHTML = '';
      if (!annotations?.length) {
        return;
      }
      annotations.forEach(annotation => {
        if (!annotation?.rect) {
          return;
        }
        const rect = pdfjsLib.Util.normalizeRect(annotation.rect);
        const [x1, y1, x2, y2] = viewport.convertToViewportRectangle(rect.slice());
        const left = Math.min(x1, x2);
        const top = Math.min(y1, y2);
        const width = Math.abs(x1 - x2);
        const height = Math.abs(y1 - y2);
        if (width === 0 || height === 0) {
          return;
        }
        const link = document.createElement('a');
        link.className = 'annotation-link';
        link.style.left = `${left}px`;
        link.style.top = `${top}px`;
        link.style.width = `${width}px`;
        link.style.height = `${height}px`;

        if (annotation.url) {
          link.href = annotation.url;
          link.target = '_blank';
          link.rel = 'noopener';
          link.title = annotation.title || annotation.url;
        } else if (annotation.dest || annotation.action) {
          const destination = annotation.dest || annotation.action;
          link.href = '#';
          link.title = 'Go to referenced section';
          link.addEventListener('click', event => {
            event.preventDefault();
            goToDestination(destination);
          });
        } else {
          link.style.pointerEvents = 'none';
          link.tabIndex = -1;
        }
        container.appendChild(link);
      });
    }

    async function goToDestination(rawDestination) {
      if (!pdfDoc || !rawDestination) {
        return;
      }
      let destination = null;
      try {
        if (Array.isArray(rawDestination)) {
          destination = rawDestination;
        } else if (rawDestination && typeof rawDestination === 'object' && Array.isArray(rawDestination.dest)) {
          destination = rawDestination.dest;
        } else if (typeof rawDestination === 'string') {
          destination = await pdfDoc.getDestination(rawDestination);
        } else {
          destination = await pdfDoc.getDestination(rawDestination);
        }
      } catch (error) {
        console.warn('Unable to resolve PDF destination', rawDestination, error);
        return;
      }
      if (!destination || !destination.length) {
        return;
      }
      const [ref] = destination;
      try {
        let pageIndex = null;
        if (typeof ref === 'object' && ref !== null) {
          pageIndex = await pdfDoc.getPageIndex(ref);
        } else if (Number.isFinite(ref)) {
          pageIndex = ref;
        }
        if (!Number.isFinite(pageIndex)) {
          return;
        }
        currentPage = Math.min(pdfDoc.numPages, pageIndex + 1);
        renderSpread();
      } catch (error) {
        console.warn('Unable to navigate to destination', error);
      }
    }

    function goToPrevious() {
      if (!pdfDoc) {
        return;
      }
      const visible = getVisiblePages();
      if (!visible.length || visible[0] <= 1) {
        hideNavButton(prevBtn, true);
        return;
      }
      currentPage = Math.max(1, currentPage - 1);
      renderSpread();
    }

    function goToNext() {
      if (!pdfDoc) {
        return;
      }
      const visible = getVisiblePages();
      if (!visible.length || visible[visible.length - 1] >= pdfDoc.numPages) {
        hideNavButton(nextBtn, true);
        return;
      }
      currentPage = Math.min(pdfDoc.numPages, currentPage + 1);
      renderSpread();
    }

    function setStatus(message) {
      if (!pageLabel) {
        return;
      }
      const container = pageLabel.closest('.user-guide-status');
      const hasMessage = Boolean(message && String(message).trim());
      pageLabel.textContent = message || '';
      if (container) {
        container.classList.toggle('is-hidden', !hasMessage);
      }
    }

    function updateNavState(pages) {
      if (!pdfDoc || !pages.length) {
        hideNavButton(prevBtn, true);
        hideNavButton(nextBtn, true);
        return;
      }
      const first = pages[0];
      const last = pages[pages.length - 1];
      hideNavButton(prevBtn, first <= 1);
      hideNavButton(nextBtn, last >= pdfDoc.numPages);
    }

    function hideNavButton(button, shouldHide) {
      if (!button) {
        return;
      }
      button.disabled = shouldHide;
      if (shouldHide) {
        button.classList.add('is-hidden');
        button.setAttribute('aria-hidden', 'true');
        button.tabIndex = -1;
      } else {
        button.classList.remove('is-hidden');
        button.removeAttribute('aria-hidden');
        button.tabIndex = 0;
      }
    }

    function updateNavOffset() {
      if (!viewer || !spread) {
        return;
      }
      const firstPage = spread.querySelector('.guide-page');
      const pageList = Array.from(spread.querySelectorAll('.guide-page'));
      const lastPage = pageList.length ? pageList[pageList.length - 1] : null;
      if (!firstPage || !lastPage) {
        viewer.style.setProperty('--nav-offset-prev', '10px');
        viewer.style.setProperty('--nav-offset-next', '10px');
        viewer.style.removeProperty('--nav-vertical-center');
        return;
      }
      const viewerRect = viewer.getBoundingClientRect();
      const firstRect = firstPage.getBoundingClientRect();
      const lastRect = lastPage.getBoundingClientRect();
      const prevWidth = prevBtn?.offsetWidth || 56;
      const nextWidth = nextBtn?.offsetWidth || 56;
      const prevOffset = Math.max(6, Math.round(firstRect.left - viewerRect.left - prevWidth * 0.45));
      const nextOffset = Math.max(6, Math.round(viewerRect.right - lastRect.right - nextWidth * 0.45));
      viewer.style.setProperty('--nav-offset-prev', `${prevOffset}px`);
      viewer.style.setProperty('--nav-offset-next', `${nextOffset}px`);

      const pagesTop = Math.min(firstRect.top, lastRect.top);
      const pagesBottom = Math.max(firstRect.bottom, lastRect.bottom);
      const relativeCenter = ((pagesTop + pagesBottom) / 2) - viewerRect.top;
      const viewerHeight = viewerRect.height || viewer.offsetHeight || MIN_FRAME_HEIGHT;
      const clampedCenter = Math.min(Math.max(relativeCenter, 0), viewerHeight);
      if (Number.isFinite(clampedCenter)) {
        viewer.style.setProperty('--nav-vertical-center', `${Math.round(clampedCenter)}px`);
      } else {
        viewer.style.removeProperty('--nav-vertical-center');
      }
    }

    function lockSpreadHeight() {
      if (!spread) {
        return () => {};
      }
      const measured = spread.offsetHeight || spread.scrollHeight || 0;
      if (measured > 0) {
        spread.style.minHeight = `${measured}px`;
      }
      return () => {
        if (spread) {
          spread.style.minHeight = '';
        }
      };
    }

    function getElementBottom(el) {
      if (!el) {
        return 0;
      }
      const rect = el.getBoundingClientRect();
      const scrollOffset = window.scrollY || window.pageYOffset || 0;
      return Math.max(0, Math.round((rect.bottom || 0) + scrollOffset));
    }

    function computeWrapperHeight() {
      const spreadHeight = spread?.offsetHeight || spread?.scrollHeight || 0;
      if (spreadHeight > 0) {
        const paddedHeight = Math.round(spreadHeight + WRAPPER_BUFFER);
        return Math.max(MIN_FRAME_HEIGHT, paddedHeight);
      }
      const referenceHeight = getReferenceViewportHeight();
      if (referenceHeight > 0) {
        return Math.max(MIN_FRAME_HEIGHT, referenceHeight);
      }
      return Math.max(MIN_FRAME_HEIGHT + WRAPPER_BUFFER, 600);
    }

    function applyWrapperHeight() {
      if (!viewer) {
        return MIN_FRAME_HEIGHT;
      }
      const height = computeWrapperHeight();
      viewer.style.minHeight = `${height}px`;
      return height;
    }

    function measureContentHeight() {
      const shellHeight = shell?.offsetHeight || shell?.scrollHeight || 0;
      const wrapperHeight = wrapper?.offsetHeight || wrapper?.scrollHeight || 0;
      const viewerHeight = viewer?.offsetHeight || viewer?.scrollHeight || 0;
      const primaryHeight = Math.max(shellHeight, wrapperHeight, viewerHeight);
      if (primaryHeight > 0) {
        return Math.max(MIN_FRAME_HEIGHT, Math.round(primaryHeight + FOOTER_CLAMP_BUFFER - FOOTER_SHADOW_OVERHANG));
      }
      const shellBottom = getElementBottom(shell);
      const wrapperBottom = getElementBottom(wrapper);
      const viewerBottom = getElementBottom(viewer);
      const positionFallback = Math.max(shellBottom || 0, wrapperBottom || 0, viewerBottom || 0);
      if (positionFallback > 0) {
        return Math.max(MIN_FRAME_HEIGHT, Math.round(positionFallback + FOOTER_CLAMP_BUFFER - FOOTER_SHADOW_OVERHANG));
      }
      const body = document.body;
      const html = document.documentElement;
      const documentHeight = Math.max(
        body?.scrollHeight || 0,
        body?.offsetHeight || 0,
        html?.scrollHeight || 0,
        html?.offsetHeight || 0
      );
      if (documentHeight > 0) {
        return Math.max(MIN_FRAME_HEIGHT, Math.round(documentHeight));
      }
      return Math.max(MIN_FRAME_HEIGHT + WRAPPER_BUFFER, 600);
    }

    function sendHeightToParent() {
      try {
        applyWrapperHeight();
        const height = measureContentHeight();
        window.parent.postMessage({
          type: 'contentHeight',
          chart: 'user-guide',
          height
        }, '*');
      } catch (error) {
        console.warn('Unable to post user-guide height', error);
      }
    }

    function scheduleHeightUpdate(delay = 60) {
      if (heightTimer) {
        window.clearTimeout(heightTimer);
      }
      heightTimer = window.setTimeout(() => {
        heightTimer = null;
        window.requestAnimationFrame(sendHeightToParent);
      }, delay);
    }

    function updateViewportMetrics(payload) {
      if (payload && Number.isFinite(payload.viewportHeight)) {
        parentViewportHeight = payload.viewportHeight;
      }
      if (payload && Number.isFinite(payload.footerHeight)) {
        parentFooterHeight = payload.footerHeight;
      }
      applyWrapperHeight();
      scheduleHeightUpdate(30);
    }

    function getReferenceViewportHeight() {
      const rawViewport = parentViewportHeight || window.innerHeight || (MIN_FRAME_HEIGHT + WRAPPER_BUFFER + parentFooterHeight);
      const footerReserve = Math.max(0, parentFooterHeight) + FOOTER_VIEWPORT_GAP;
      const shellReserve = getShellViewportReserve();
      const available = rawViewport - footerReserve - shellReserve;
      return Math.max(MIN_FRAME_HEIGHT, Math.round(available));
    }

    async function renderTextLayerContent({ textContent, textLayer, viewport }) {
      if (renderTextLayerFn) {
        return renderTextLayerFn({
          textContent,
          container: textLayer,
          viewport,
          textDivs: []
        }).promise;
      }
      if (TextLayerClass) {
        const textLayerRenderer = new TextLayerClass({
          textContentSource: textContent,
          container: textLayer,
          viewport
        });
        return textLayerRenderer.render();
      }
      console.warn('PDF text-layer rendering is unavailable in this build.');
      return Promise.resolve();
    }

    function requestParentMetrics() {
      try {
        window.parent.postMessage({
          type: 'requestParentViewportMetrics',
          chart: 'user-guide'
        }, '*');
      } catch (error) {
        console.warn('Unable to request parent viewport metrics', error);
      }
    }

    async function updateDocumentAspectRatio() {
      if (!pdfDoc) {
        documentAspectRatio = DEFAULT_PAGE_ASPECT_RATIO;
        return;
      }
      try {
        const page = await pdfDoc.getPage(1);
        const viewport = page.getViewport({ scale: 1 });
        const ratio = viewport.height / viewport.width;
        if (Number.isFinite(ratio) && ratio > 0) {
          documentAspectRatio = ratio;
        } else {
          documentAspectRatio = DEFAULT_PAGE_ASPECT_RATIO;
        }
      } catch (error) {
        documentAspectRatio = DEFAULT_PAGE_ASPECT_RATIO;
        console.warn('Unable to determine user guide page ratio', error);
      }
    }

    function getCurrentAspectRatio() {
      const ratio = documentAspectRatio || DEFAULT_PAGE_ASPECT_RATIO;
      if (!Number.isFinite(ratio) || ratio <= 0) {
        return DEFAULT_PAGE_ASPECT_RATIO;
      }
      return ratio;
    }

    window.addEventListener('unload', () => {
      try {
        worker?.terminate();
      } catch (error) {
        console.warn('Unable to terminate PDF worker', error);
      }
    });
    })();
  </script>
  <script src="../SharedResources/supabase-env.js"></script>
  <script src="../SharedResources/supabase-config.js"></script>
  <script src="../SharedResources/analytics.js"></script>
</body>
</html>
