<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>UK Air Pollution/Emissions Data Explorer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Interactive charts using UK Government data">
  <meta property="og:type" content="website">
  <meta property="og:title" content="UK Air Pollution and Emissions Data Explorer">
  <meta property="og:description" content="Interactive charts using UK Government data">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="UK Air Pollution and Emissions Data Explorer">
  <meta name="twitter:description" content="Interactive charts using UK Government data">
  <link rel="stylesheet" href="../dist/tailwind.css">
  <link rel="stylesheet" href="../SharedResources/common-styles.css">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #ffffff;
      color: #1f2937;
      margin: 0;
      padding: 0;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    #categoryTable {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.95rem;
      color: #0f172a;
      font-family: inherit;
    }

    #categoryTable th,
    #categoryTable td {
      border: 1px solid #444;
      padding: 12px;
      text-align: left;
      vertical-align: top;
      white-space: pre-line;
    }

    #categoryTable td {
      position: relative;
      transition: background-color 0.25s ease;
    }

    #categoryTable thead tr {
      background: #d0d0d0;
    }

    #categoryTable tbody tr {
      cursor: pointer;
    }

    #categoryTable tbody tr:hover {
      background: #f5f5f5;
    }

    #categoryTable th:nth-child(1),
    #categoryTable td:nth-child(1) {
      width: 26%;
    }

    #categoryTable th:nth-child(2),
    #categoryTable td:nth-child(2) {
      width: 6.5%;
      white-space: nowrap;
    }

    #categoryTable th:nth-child(3),
    #categoryTable td:nth-child(3) {
      width: 39.5%;
    }

    #categoryTable th:nth-child(4),
    #categoryTable td:nth-child(4) {
      width: 28%;
    }

    .category-info-source-heading {
      text-decoration: underline;
      font-weight: 600;
      display: block;
      margin-bottom: 4px;
    }

    .category-info-source-heading mark.category-info-highlight {
      text-decoration: inherit;
    }

    .category-info-item-list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 4px;
    }

    .category-info-item {
      display: block;
      line-height: 1.25;
    }

    mark.category-info-highlight {
      background: rgba(255, 174, 1, 0.45);
      color: #5b2109;
      padding: 0;
      border-radius: 2px;
      box-decoration-break: clone;
      -webkit-box-decoration-break: clone;
    }

    .category-info-activity-column {
      text-align: left !important;
      vertical-align: middle;
    }

    .category-info-activity-heading {
      display: inline-block;
      text-align: left;
      line-height: 1.1;
    }

    .category-info-activity-cell {
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
      padding-right: 12px;
      line-height: 1;
      position: relative;
      min-height: 24px;
    }

    .category-info-activity-icon {
      width: 24px;
      height: 24px;
      position: absolute;
      top: 12px;
      left: 12px;
    }

    .category-info-row-copying td {
      background: #00C109 !important;
    }

    .category-info-copied-label {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ffffff;
      font-weight: 700;
      letter-spacing: 0.05em;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1;
      text-transform: uppercase;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
    }

    .category-info-copied-label.is-visible {
      opacity: 1;
    }

    @media (min-width: 980px) {
      .category-info-item-list--multi {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .category-info-shell {
      padding: 20px;
    }

    @media (min-width: 620px) {
      .category-info-shell {
        /* Leave breathing room for the fixed social sidebar in the parent shell */
        padding-right: 150px;
      }
    }

    .category-info-shell .main-title {
      font-size: 26px;
      font-weight: 700;
      line-height: 1.3;
      margin: 0 0 12px 0;
      padding-right: 0;
    }

    .category-info-frame {
      width: 100%;
      margin: 0;
      border-radius: 6px;
      background: #ffffff;
      box-sizing: border-box;
      padding: 0 4px 12px 4px;
      overflow: visible;
      box-shadow: none;
      border: none;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .category-info-filter-block {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      margin: 0 0 10px;
      max-width: 100%;
    }

    .category-info-filter-label {
      font-size: 1.1rem;
      font-weight: 600;
      color: #1f2937;
      white-space: nowrap;
    }

    .category-info-filter-input {
      flex: 1 1 320px;
      min-width: 240px;
      padding: 10px 14px;
      border: 1px solid #cbd5e1;
      border-radius: 6px;
      font-size: 1rem;
      font-family: inherit;
      color: #0f172a;
      background-color: #fff;
    }

    .category-info-filter-input:disabled {
      cursor: not-allowed;
      background-color: #f1f5f9;
      color: #94a3b8;
      border-color: #d1d5db;
    }

    .category-info-filter-input:focus {
      outline: 2px solid #ff9301;
      outline-offset: 1px;
    }

    .category-info-column-filters {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .category-info-column-label {
      font-size: 0.95rem;
      font-weight: 600;
      color: #1f2937;
      white-space: nowrap;
    }

    .category-info-column-options {
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
    }

    .category-info-column-option {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.95rem;
      color: #1f2937;
    }

    .category-info-table-container {
      margin-top: 10px;
      overflow-x: auto;
    }

    .status-text {
      font-size: 0.75rem;
      color: #6b7280;
      margin: 0;
    }

    @media (max-width: 620px) {
      .category-info-frame {
        padding: 0 24px 32px 0;
      }

      .category-info-shell {
        padding: 20px;
      }
    }
  </style>
  <script>
    (function preloadSharedReferences() {
      try {
        if (!window.SharedDataLoader && window.parent && window.parent.SharedDataLoader) {
          window.SharedDataLoader = window.parent.SharedDataLoader;
        }
      } catch (error) {
        console.warn('Unable to mirror SharedDataLoader from parent frame:', error);
      }

      try {
        if (!window.SupabaseConfig && window.parent && window.parent.SupabaseConfig) {
          window.SupabaseConfig = window.parent.SupabaseConfig;
        }
      } catch (error) {
        console.warn('Unable to mirror SupabaseConfig from parent frame:', error);
      }
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <script src="../SharedResources/supabase-env.js"></script>
  <script src="../SharedResources/supabase-config.js"></script>
  <script src="../SharedResources/shared-data-loader.js"></script>
</head>
<body>
  <main class="chart-shell category-info-shell">
    <div class="title-row">
      <h2 class="main-title" id="category-info-heading">Pollution Category Information</h2>
    </div>
    <section class="category-info-frame" aria-labelledby="category-info-heading">

      <div class="category-info-filter-block">
        <label for="category-info-filter-input" class="category-info-filter-label">Filter:</label>
        <input type="search" id="category-info-filter-input" class="category-info-filter-input" placeholder="Search categories, sources, or fuel types" autocomplete="off" aria-describedby="category-info-filter-columns-label">
      </div>

      <div class="category-info-column-filters" role="group" aria-labelledby="category-info-filter-columns-label">
        <span class="category-info-column-label" id="category-info-filter-columns-label">Filter Columns:</span>
        <div class="category-info-column-options">
          <label class="category-info-column-option">
            <input type="checkbox" id="category-info-filter-column-all" value="all" checked>
            <span>All</span>
          </label>
          <label class="category-info-column-option">
            <input type="checkbox" id="category-info-filter-column-name" value="name" checked>
            <span>Category Name</span>
          </label>
          <label class="category-info-column-option">
            <input type="checkbox" id="category-info-filter-column-sources" value="sources" checked>
            <span>Sources &amp; NFR Code</span>
          </label>
          <label class="category-info-column-option">
            <input type="checkbox" id="category-info-filter-column-fuels" value="fuels" checked>
            <span>Fuel Types</span>
          </label>
        </div>
      </div>

      <p id="category-info-status" class="status-text sr-only" aria-live="polite"></p>

      <div class="category-info-table-container">
        <div id="category-info-content"></div>
      </div>
    </section>
  </main>

  <script>
    (function() {
      const statusEl = document.getElementById('category-info-status');
      const contentEl = document.getElementById('category-info-content');
      const overlayEl = document.getElementById('category-info-overlay');
      const overlayMessageEl = overlayEl ? overlayEl.querySelector('.category-info-overlay-message') : null;
      const filterInput = document.getElementById('category-info-filter-input');
      const columnOptionsEl = document.querySelector('.category-info-column-options');
      const columnCheckboxes = columnOptionsEl ? Array.from(columnOptionsEl.querySelectorAll('input[type="checkbox"]')) : [];
      let statusTimer = null;
      let categoryInfoState = null;
      const highlightMatchesEnabled = true;
      let filterInputActive = true;
      const MIN_HEIGHT_DELTA = 8;
      const MIN_CONTENT_HEIGHT = 320;
      const FALLBACK_MIN_CONTENT_HEIGHT = 1100;
      const IS_EMBEDDED = Boolean(window.parent && window.parent !== window);
      let sharedLoaderRef = null;
      let lastSentHeight = 0;
      let contentResizeObserver = null;
      let pendingHeightUpdateId = null;
      let hasPostedInitialHeight = false;
      let initialLayoutReadyPromise = null;
      let initialContentReady = false;
      let chartReadyPosted = false;
      let parentHeightRequestPending = false;
      const overlayHiddenClass = 'category-info-overlay--hidden';
      let overlayVisible = false;
      const actDataStatus = {
        ready: false,
        hasActDataByCategoryName: new Map(),
        hasActDataByCategoryId: new Map(),
        categoriesWithoutActData: []
      };
      const DEFAULT_SNAPSHOT_PATHS = [
        '/SharedResources/default-chart-data.json',
        '../SharedResources/default-chart-data.json',
        '../../SharedResources/default-chart-data.json'
      ];
      let defaultSnapshotPromise = null;
      let cachedDefaultSnapshot = null;
      let directCategoryDatasetPromise = null;
      let directCategoryDataset = null;
      let supabaseClient = null;
      let categoryInfoDatasetSource = 'unknown';

      function resolveSupabaseConfig() {
        if (window.SupabaseConfig?.initSupabaseClient) {
          return window.SupabaseConfig;
        }
        try {
          if (window.parent && window.parent !== window && window.parent.SupabaseConfig?.initSupabaseClient) {
            window.SupabaseConfig = window.parent.SupabaseConfig;
            return window.SupabaseConfig;
          }
        } catch (error) {
          console.warn('Unable to access SupabaseConfig reference:', error);
        }
        return null;
      }

      function getSupabaseClient() {
        if (supabaseClient) {
          return supabaseClient;
        }
        const config = resolveSupabaseConfig();
        if (!config?.initSupabaseClient) {
          return null;
        }
        try {
          supabaseClient = config.initSupabaseClient();
        } catch (error) {
          console.warn('Failed to initialize Supabase client for category info:', error);
        }
        return supabaseClient;
      }

      async function loadDefaultSnapshot() {
        if (cachedDefaultSnapshot) {
          return cachedDefaultSnapshot;
        }
        if (!defaultSnapshotPromise) {
          defaultSnapshotPromise = (async () => {
            for (const path of DEFAULT_SNAPSHOT_PATHS) {
              try {
                const response = await fetch(path, { cache: 'no-store' });
                if (!response.ok) {
                  continue;
                }
                const snapshot = await response.json();
                cachedDefaultSnapshot = snapshot;
                return snapshot;
              } catch (error) {
                console.warn('Default snapshot fetch failed:', error);
              }
            }
            return null;
          })();
        }
        const snapshot = await defaultSnapshotPromise;
        if (snapshot && !cachedDefaultSnapshot) {
          cachedDefaultSnapshot = snapshot;
        }
        return snapshot;
      }

      async function fetchCategoriesAndNfrDirectly() {
        if (directCategoryDataset) {
          return directCategoryDataset;
        }
        if (directCategoryDatasetPromise) {
          return directCategoryDatasetPromise;
        }

        const client = getSupabaseClient();
        if (!client) {
          return null;
        }

        directCategoryDatasetPromise = (async () => {
          try {
            const [categoriesResp, nfrResp] = await Promise.all([
              client.from('naei_global_t_category').select('*'),
              client.from('naei_global_t_nfrcode').select('*')
            ]);

            if (categoriesResp.error) {
              throw categoriesResp.error;
            }
            if (nfrResp.error) {
              throw nfrResp.error;
            }

            directCategoryDataset = {
              categories: categoriesResp.data || [],
              nfrCodes: nfrResp.data || []
            };
            return directCategoryDataset;
          } catch (error) {
            console.warn('Direct category info fetch failed:', error);
            return null;
          } finally {
            directCategoryDatasetPromise = null;
          }
        })();

        return directCategoryDatasetPromise;
      }

      async function getActDataSnapshotDataset() {
        const loader = resolveSharedDataLoader();
        if (loader?.loadDefaultSnapshot) {
          try {
            const snapshot = await loader.loadDefaultSnapshot();
            if (snapshot?.data) {
              return snapshot.data;
            }
          } catch (error) {
            console.warn('Shared loader default snapshot unavailable:', error);
          }
        }
        const snapshot = await loadDefaultSnapshot();
        if (snapshot?.data) {
          return snapshot.data;
        }
        return snapshot || null;
      }

      function requestSharedDatasetBootstrap(reason = 'category-info') {
        const loader = resolveSharedDataLoader();
        if (!loader) {
          return;
        }
        if (typeof loader.bootstrapFullDataset === 'function') {
          loader.bootstrapFullDataset(reason).catch(error => {
            console.warn('Shared dataset bootstrap failed (category-info):', error);
          });
          return;
        }
        if (typeof loader.loadSharedData === 'function') {
          loader.loadSharedData().catch(error => {
            console.warn('Shared dataset load failed (category-info):', error);
          });
        }
      }

      if (typeof ResizeObserver === 'function' && contentEl) {
        contentResizeObserver = new ResizeObserver(() => scheduleHeightUpdate(24));
        contentResizeObserver.observe(contentEl);
      }

      function setFilterInputState(isActive) {
        if (!filterInput) {
          return;
        }

        filterInputActive = Boolean(isActive);
        filterInput.disabled = !filterInputActive;
        filterInput.setAttribute('aria-disabled', filterInputActive ? 'false' : 'true');
        if (!filterInputActive) {
          filterInput.blur();
        }
      }

      function isFilterInputActive() {
        return filterInputActive;
      }

      function resolveSharedDataLoader() {
        if (sharedLoaderRef) {
          return sharedLoaderRef;
        }
        try {
          if (window.SharedDataLoader) {
            sharedLoaderRef = window.SharedDataLoader;
            return sharedLoaderRef;
          }
          if (window.parent && window.parent !== window && window.parent.SharedDataLoader) {
            sharedLoaderRef = window.parent.SharedDataLoader;
            window.SharedDataLoader = sharedLoaderRef;
            return sharedLoaderRef;
          }
        } catch (error) {
          console.warn('Unable to access SharedDataLoader reference:', error);
        }
        return null;
      }

      function setStatus(message, persist = false) {
        if (!statusEl) return;
        statusEl.textContent = message || '';

        if (!persist) {
          clearTimeout(statusTimer);
          statusTimer = setTimeout(() => {
            statusEl.textContent = '';
          }, 4000);
        }
      }

      function markInitialContentReady() {
        if (initialContentReady) {
          return;
        }
        initialContentReady = true;
        notifyParentChartReady();
        if (parentHeightRequestPending) {
          parentHeightRequestPending = false;
          scheduleHeightUpdate(120, { force: true, awaitInitialSettlement: true });
        }
      }

      function notifyParentChartReady() {
        if (!IS_EMBEDDED || chartReadyPosted) {
          return;
        }
        chartReadyPosted = true;
        try {
          window.parent.postMessage({
            type: 'chartReady',
            chart: 'category-info'
          }, '*');
        } catch (error) {
          console.warn('Unable to notify parent frame that category info is ready:', error);
        }
      }

      function getElementBottom(el) {
        if (!el) {
          return 0;
        }
        const rect = el.getBoundingClientRect();
        const scrollOffset = window.scrollY || window.pageYOffset || 0;
        return Math.max(0, Math.round((rect.bottom || 0) + scrollOffset));
      }

      function measureHeight() {
        const body = document.body;
        const html = document.documentElement;
        const documentHeight = Math.max(
          body?.scrollHeight || 0,
          body?.offsetHeight || 0,
          html?.scrollHeight || 0,
          html?.offsetHeight || 0
        );

        const shell = document.querySelector('.category-info-shell');
        const frame = document.querySelector('.category-info-frame');
        const content = document.getElementById('category-info-content');
        const overlayActive = overlayEl && !overlayEl.classList.contains(overlayHiddenClass) ? overlayEl : null;

        const candidates = [
          { label: 'shell', value: getElementBottom(shell) },
          { label: 'frame', value: getElementBottom(frame) },
          { label: 'content', value: getElementBottom(content) }
        ];

        if (overlayActive) {
          candidates.push({ label: 'overlay', value: getElementBottom(overlayActive) });
        }

        const validCandidates = candidates.filter(entry => Number.isFinite(entry.value) && entry.value > 0);
        let measuredHeight = 0;

        if (validCandidates.length) {
          const bestCandidate = validCandidates.reduce((prev, next) => (next.value > prev.value ? next : prev));
          measuredHeight = bestCandidate.value;
        }

        const fallbackEstimate = Math.max(MIN_CONTENT_HEIGHT, documentHeight || 0);

        if (!measuredHeight && documentHeight) {
          measuredHeight = documentHeight;
        }

        if (!measuredHeight) {
          measuredHeight = fallbackEstimate;
        }

        if (measuredHeight < 300) {
          measuredHeight = Math.max(FALLBACK_MIN_CONTENT_HEIGHT, fallbackEstimate);
        }

        return Math.max(Math.ceil(measuredHeight), MIN_CONTENT_HEIGHT);
      }

      function waitForInitialLayoutSettlement() {
        if (initialLayoutReadyPromise) {
          return initialLayoutReadyPromise;
        }

        const waits = [];

        if (document.fonts?.ready && typeof document.fonts.ready.then === 'function') {
          waits.push(document.fonts.ready.catch(() => undefined));
        }

        waits.push(new Promise(resolve => {
          requestAnimationFrame(() => {
            requestAnimationFrame(resolve);
          });
        }));

        initialLayoutReadyPromise = Promise.all(waits).then(() => {
          initialLayoutReadyPromise = Promise.resolve();
        });

        return initialLayoutReadyPromise;
      }

      async function sendHeightToParent(force = false, options = {}) {
        try {
          if (!IS_EMBEDDED) {
            return;
          }
          if (options.awaitInitialSettlement && !hasPostedInitialHeight) {
            try {
              await waitForInitialLayoutSettlement();
            } catch (settleError) {
              console.warn('Initial layout settlement wait failed:', settleError);
            }
          }
          const height = Math.max(MIN_CONTENT_HEIGHT, measureHeight());
          if (!force && lastSentHeight && Math.abs(height - lastSentHeight) < MIN_HEIGHT_DELTA) {
            return;
          }
          lastSentHeight = height;
          hasPostedInitialHeight = true;
          window.parent.postMessage({
            type: 'contentHeight',
            chart: 'category-info',
            height
          }, '*');
        } catch (error) {
          console.warn('Unable to send category info height to parent:', error);
        }
      }

      function scheduleHeightUpdate(delay = 50, options = {}) {
        if (!IS_EMBEDDED) {
          return;
        }
        const force = Boolean(options.force);
        const awaitInitialSettlement = Boolean(options.awaitInitialSettlement);
        if (!hasPostedInitialHeight && !force) {
          return;
        }
        if (pendingHeightUpdateId) {
          clearTimeout(pendingHeightUpdateId);
        }
        pendingHeightUpdateId = setTimeout(() => {
          pendingHeightUpdateId = null;
          requestAnimationFrame(() => {
            sendHeightToParent(force, {
              awaitInitialSettlement: awaitInitialSettlement || (force && !hasPostedInitialHeight)
            });
          });
        }, Math.max(0, delay));
      }

      function showLoadingOverlay(message = 'Loading category informationâ€¦') {
        if (overlayMessageEl) {
          overlayMessageEl.textContent = message;
        }
        if (overlayEl) {
          overlayEl.classList.remove(overlayHiddenClass);
        }
        overlayVisible = true;
      }

      function hideLoadingOverlay() {
        if (!overlayVisible) {
          return;
        }
        if (overlayEl) {
          overlayEl.classList.add(overlayHiddenClass);
        }
        overlayVisible = false;
        scheduleHeightUpdate(40);
      }

      async function ensureSharedDataLoaded() {
        const loader = resolveSharedDataLoader();
        if (loader) {
          if (loader.isDataLoaded?.()) {
            try {
              categoryInfoDatasetSource = 'shared-cache';
              return loader.getCachedData();
            } catch (error) {
              console.warn('Unable to read cached shared data:', error);
            }
          }

          try {
            if (typeof loader.loadSharedData === 'function') {
              const payload = await loader.loadSharedData();
              if (payload) {
                categoryInfoDatasetSource = 'shared-loader';
                return payload;
              }
            }
          } catch (error) {
            console.warn('Shared data loader failed while preparing category info page:', error);
          }

          if (loader.isDataLoaded?.()) {
            try {
              const cached = loader.getCachedData();
              if (cached) {
                categoryInfoDatasetSource = 'shared-cache-fallback';
                return cached;
              }
            } catch (error) {
              console.warn('Shared data cache unavailable after load attempt:', error);
            }
          }
        }

        const directPayload = await fetchCategoriesAndNfrDirectly();
        if (directPayload?.categories?.length || directPayload?.groups?.length) {
          categoryInfoDatasetSource = 'direct-supabase';
          return {
            pollutants: [],
            categories: directPayload.categories || directPayload.groups,
            timeseries: [],
            nfrCodes: directPayload.nfrCodes || []
          };
        }

        if (!loader) {
          console.warn('Shared data loader unavailable when preparing category info page.');
        }

        categoryInfoDatasetSource = 'unavailable';
        return null;
      }

      async function ensureActDataStatus() {
        if (actDataStatus.ready) {
          return actDataStatus;
        }

        let dataset = null;
        const loader = resolveSharedDataLoader();

        if (loader) {
          try {
            if (loader.isDataLoaded?.()) {
              dataset = loader.getCachedData();
            } else if (typeof loader.loadDefaultSnapshot === 'function') {
              const snapshot = await loader.loadDefaultSnapshot();
              dataset = snapshot?.data || snapshot || null;
            }
          } catch (error) {
            console.warn('Unable to access shared ActData dataset from cache:', error);
          }

          if (!dataset && typeof loader.loadSharedData === 'function') {
            try {
              const payload = await loader.loadSharedData();
              dataset = payload || null;
            } catch (error) {
              console.warn('Shared loader full dataset unavailable for ActData status:', error);
            }
          }
        }

        if (!dataset) {
          dataset = await getActDataSnapshotDataset();
        }

        if (!dataset) {
          return actDataStatus;
        }

        const pollutants = Array.isArray(dataset.pollutants)
          ? dataset.pollutants
          : Array.isArray(dataset?.data?.pollutants)
            ? dataset.data.pollutants
            : [];
        const categories = Array.isArray(dataset.categories)
          ? dataset.categories
          : Array.isArray(dataset.groups)
            ? dataset.groups
            : Array.isArray(dataset?.data?.categories)
              ? dataset.data.categories
              : Array.isArray(dataset?.data?.groups)
                ? dataset.data.groups
                : [];
        const timeseries = Array.isArray(dataset.timeseries)
          ? dataset.timeseries
          : Array.isArray(dataset.rows)
            ? dataset.rows
            : Array.isArray(dataset?.data?.timeseries)
              ? dataset.data.timeseries
              : Array.isArray(dataset?.data?.rows)
                ? dataset.data.rows
                : [];

        const actDataRowsByCategoryId = new Map();
        let yearColumns = [];
        let actDataPollutant = null;

        if (pollutants.length && timeseries.length) {
          actDataPollutant = pollutants.find(entry => typeof entry?.pollutant === 'string' && entry.pollutant.toLowerCase() === 'activity data') || null;
          if (actDataPollutant) {
            const sampleRow = timeseries.find(row => row?.pollutant_id === actDataPollutant.id) || null;
            if (sampleRow) {
              yearColumns = Object.keys(sampleRow)
                .filter(key => /^f\d{4}$/.test(key))
                .sort((a, b) => a.localeCompare(b));
            }
            timeseries.forEach(row => {
              if (row?.pollutant_id === actDataPollutant.id) {
                actDataRowsByCategoryId.set(row.category_id, row);
              }
            });
          }
        }

        const supportsActRows = Boolean(actDataPollutant && yearColumns.length && actDataRowsByCategoryId.size);
        const hasCategoryFlagData = categories.some(category => typeof category?.has_activity_data === 'boolean');

        if (!supportsActRows && !hasCategoryFlagData) {
          console.warn('Activity Data signals unavailable; cannot compute ActData availability.');
          return actDataStatus;
        }

        const hasActDataByCategoryName = new Map();
        const hasActDataByCategoryId = new Map();
        const missingNamesSet = new Set();

        categories.forEach(category => {
          const rawName = normalizeValue(
            category?.category_title
            || category?.group_name
            || category?.name
          );
          if (!rawName) {
            return;
          }
          const key = rawName.toLowerCase();
          let hasActData = false;
          const actRow = actDataRowsByCategoryId.get(category.id);

          if (actRow && yearColumns.length) {
            hasActData = yearColumns.some(column => {
              const value = actRow[column];
              if (value === null || value === undefined) {
                return false;
              }
              const numeric = Number(value);
              return Number.isFinite(numeric) && numeric !== 0;
            });
          }

          if (!hasActData && typeof category?.has_activity_data === 'boolean') {
            hasActData = category.has_activity_data;
          }

          if (key === 'all') {
            hasActData = false;
          }

          hasActDataByCategoryName.set(key, hasActData);
          hasActDataByCategoryId.set(category.id, hasActData);
          if (!hasActData) {
            missingNamesSet.add(rawName);
          }
        });

        actDataStatus.ready = true;
        actDataStatus.hasActDataByCategoryName = hasActDataByCategoryName;
        actDataStatus.hasActDataByCategoryId = hasActDataByCategoryId;
        actDataStatus.categoriesWithoutActData = Array.from(missingNamesSet).sort((a, b) => a.localeCompare(b));

        if (actDataStatus.categoriesWithoutActData.length) {
          window.categoriesWithoutActData = actDataStatus.categoriesWithoutActData.slice();
        }
        window.inactiveActDataCategoryIds = categories
          .filter(category => hasActDataByCategoryId.get(category.id) === false)
          .map(category => category.id);

        return actDataStatus;
      }

      function isNullToken(value) {
        if (value === null || value === undefined) {
          return true;
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          return !trimmed || trimmed.toUpperCase() === 'NULL';
        }
        return false;
      }

      function normalizeValue(value) {
        if (value === null || value === undefined) {
          return '';
        }
        if (typeof value === 'string') {
          return value.trim();
        }
        return String(value).trim();
      }

      function escapeHtml(value) {
        const stringValue = String(value ?? '');
        return stringValue.replace(/[&<>"']/g, char => ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        })[char] || char);
      }

      function escapeRegExp(value) {
        const stringValue = String(value ?? '');
        return stringValue.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function normalizeSearchTerm(rawTerm) {
        if (typeof rawTerm !== 'string') {
          return {
            tokens: [],
            combined: ''
          };
        }

        const decoded = rawTerm.normalize('NFKC');
        const squashed = decoded.replace(/[\s\u00A0]+/g, ' ').trim();
        if (!squashed) {
          return {
            tokens: [],
            combined: ''
          };
        }

        const tokens = Array.from(new Set(
          squashed
          .split(' ')
          .map(part => part.trim())
          .filter(Boolean)
          .map(part => part.toLowerCase())
        ));

        const combined = tokens.join('');
        return {
          tokens,
          combined
        };
      }

      function createHighlightRegex(normalized) {
        if (!highlightMatchesEnabled) {
          return null;
        }
        if (!normalized || !normalized.tokens || !normalized.tokens.length) {
          return null;
        }
        try {
          const pattern = normalized.tokens.map(token => escapeRegExp(token)).join('|');
          return new RegExp(pattern, 'gi');
        } catch (error) {
          console.warn('Unable to create highlight regex for tokens:', normalized, error);
          return null;
        }
      }

      function highlightText(value, highlightRegex) {
        const safeValue = escapeHtml(value);
        if (!highlightRegex) {
          return safeValue;
        }
        return safeValue.replace(highlightRegex, match => `<mark class="category-info-highlight">${match}</mark>`);
      }

      function buildItemList(items, options = {}, highlightRegex = null) {
        const normalizedItems = [];
        items.forEach(item => {
          const exploded = splitMultiValue(item);
          if (exploded.length) {
            normalizedItems.push(...exploded.map(part => normalizeValue(part)));
          }
        });

        const filteredItems = normalizedItems.filter(item => !isNullToken(item));

        if (!filteredItems.length) {
          return '';
        }

        const threshold = Number.isFinite(options.multiColumnThreshold) ? options.multiColumnThreshold : 6;
        const multiClass = filteredItems.length >= threshold ? ' category-info-item-list--multi' : '';
        const itemsHtml = filteredItems
          .map(item => `<span class="category-info-item">${highlightText(item, highlightRegex)}</span>`)
          .join('');

        return `<div class="category-info-item-list${multiClass}">${itemsHtml}</div>`;
      }

      function splitMultiValue(value) {
        if (Array.isArray(value)) {
          return value
            .map(item => normalizeValue(item))
            .filter(item => !isNullToken(item));
        }

        const normalized = normalizeValue(value);
        if (isNullToken(normalized)) {
          return [];
        }

        const separators = /[;\n]+/;
        if (!separators.test(normalized)) {
          return [normalized];
        }

        return normalized
          .split(separators)
          .map(item => item.trim())
          .filter(item => item.length > 0 && !isNullToken(item));
      }

      function buildCategoryMaps(categoryRows, nfrRows) {
        const nfrMap = {};
        if (Array.isArray(nfrRows)) {
          nfrRows.forEach(row => {
            const code = row?.nfr_code || row?.code;
            const description = row?.description;
            const normalizedCode = normalizeValue(code);
            const normalizedDescription = normalizeValue(description);
            if (!isNullToken(normalizedCode) && !isNullToken(normalizedDescription)) {
              nfrMap[normalizedCode] = normalizedDescription;
            }
          });
        }

        const categoryMap = {};
        categoryRows.forEach(row => {
          const rawTitle = row?.category_title || row?.group_name || row?.name;
          const categoryTitle = normalizeValue(rawTitle);
          if (isNullToken(categoryTitle)) return;

          if (!categoryMap[categoryTitle]) {
            categoryMap[categoryTitle] = {
              name: categoryTitle,
              sources: new Set(),
              activities: new Set(),
              nfrCodes: new Set()
            };
          }

          const sourceName = row?.source_name || row?.source || row?.Source;
          const activityName = row?.activity_name || row?.activity || row?.Activity;
          const nfrField = row?.nfr_code || row?.nfr_codes || '';

          const sourceValues = splitMultiValue(sourceName);
          if (sourceValues.length) {
            sourceValues.forEach(item => categoryMap[categoryTitle].sources.add(item));
          }

          const activityValues = splitMultiValue(activityName);
          if (activityValues.length) {
            activityValues.forEach(item => categoryMap[categoryTitle].activities.add(item));
          }

          const normalizedNfrField = typeof nfrField === 'string' ? nfrField : String(nfrField ?? '');
          if (normalizedNfrField.trim()) {
            normalizedNfrField
              .split(/[;,\n]/)
              .map(code => code.trim())
              .map(normalizeValue)
              .filter(code => !isNullToken(code))
              .forEach(code => categoryMap[categoryTitle].nfrCodes.add(code));
          }
        });

        const categories = Object.values(categoryMap)
          .map(g => ({
            name: g.name,
            sources: Array.from(g.sources).sort((a, b) => a.localeCompare(b)),
            activities: Array.from(g.activities).sort((a, b) => a.localeCompare(b)),
            nfrCodes: Array.from(g.nfrCodes).sort((a, b) => a.localeCompare(b))
          }))
          .sort((a, b) => {
            if (a.name?.toLowerCase() === 'all') return -1;
            if (b.name?.toLowerCase() === 'all') return 1;
            return a.name.localeCompare(b.name);
          });

        return { categories, nfrMap };
      }

      function collectSourceStrings(category, nfrMap) {
        const results = [];
        if (category.nfrCodes.length) {
          results.push('All Sources from the following NFR Code categories:');
          category.nfrCodes.forEach(code => {
            const description = nfrMap[code];
            results.push(description ? `${code}: ${description}` : code);
          });
        } else if (category.sources.length) {
          results.push(...category.sources);
        } else {
          results.push('All Sources');
        }
        return results;
      }

      function collectFuelStrings(category) {
        if (category.activities.length) {
          return [...category.activities];
        }
        return ['All Fuel Types'];
      }

      function formatSourcesCell(category, nfrMap, highlightRegex) {
        if (category.nfrCodes.length) {
          const nfrItems = category.nfrCodes.map(code => {
            const description = nfrMap[code];
            return description ? `${code}: ${description}` : code;
          });
          const heading = `<span class="category-info-source-heading">${highlightText('All Sources from the following NFR Code categories:', highlightRegex)}</span>`;
          return `${heading}${buildItemList(nfrItems, { multiColumnThreshold: 8 }, highlightRegex)}`;
        }

        if (category.sources.length) {
          return buildItemList(category.sources, { multiColumnThreshold: 8 }, highlightRegex);
        }

        return highlightText('All Sources', highlightRegex);
      }

      function formatSourcesPlainText(category, nfrMap) {
        if (category.nfrCodes.length) {
          const lines = ['All Sources from the following NFR Code categories:'];
          category.nfrCodes.forEach(code => {
            const description = nfrMap[code];
            lines.push(description ? `${code}: ${description}` : code);
          });
          return lines.join('\n');
        }
        if (category.sources.length) {
          return category.sources.join('\n');
        }
        return 'All Sources';
      }

      function formatFuelCell(category, highlightRegex) {
        if (category.activities.length) {
          return buildItemList(category.activities, { multiColumnThreshold: 8 }, highlightRegex);
        }
        return highlightText('All Fuel Types', highlightRegex);
      }

      function formatFuelPlainText(category) {
        if (category.activities.length) {
          return category.activities.join('\n');
        }
        return 'All Fuel Types';
      }

      function hasActDataForCategory(category) {
        if (!category) {
          return false;
        }
        const normalizedName = normalizeValue(category.name);
        if (!normalizedName) {
          return false;
        }
        const key = normalizedName.toLowerCase();
        if (actDataStatus.hasActDataByCategoryName && actDataStatus.hasActDataByCategoryName.has(key)) {
          return actDataStatus.hasActDataByCategoryName.get(key);
        }
        if (Array.isArray(category.activities)) {
          return category.activities.some(item => !isNullToken(item));
        }
        return false;
      }

      function getActivityIndicatorInfo(category) {
        const hasData = hasActDataForCategory(category);
        const message = hasData ? 'Yes' : 'No';
        const description = hasData ? 'Activity data available' : 'Activity data unavailable';
        const iconSrc = hasData
          ? '../SharedResources/images/Green-Square-Button-White-Tick-200x200.svg'
          : '../SharedResources/images/Red-Square-Button-White-Cross-200x200.svg';
        return {
          message,
          description,
          iconSrc
        };
      }

      function getSelectedColumnKeys() {
        if (!columnCheckboxes.length) {
          return ['name', 'sources', 'fuels'];
        }

        const checkedValues = columnCheckboxes
          .filter(box => box.checked)
          .map(box => box.value);

        if (checkedValues.includes('all')) {
          return ['name', 'sources', 'fuels'];
        }

        const keys = [];
        if (checkedValues.includes('name')) {
          keys.push('name');
        }
        if (checkedValues.includes('sources')) {
          keys.push('sources');
        }
        if (checkedValues.includes('fuels')) {
          keys.push('fuels');
        }

        return keys;
      }

      function matchesCategory(category, normalizedTerm, columnKeys, nfrMap) {
        if (!normalizedTerm || !normalizedTerm.tokens || !normalizedTerm.tokens.length) {
          return true;
        }
        const tokens = normalizedTerm.tokens;
        const combinedNeedle = normalizedTerm.combined;
        const whitespaceRegex = /[\s\u00A0]+/g;

        if (!columnKeys.length || columnKeys.includes('name')) {
          const lowerName = category.name.toLowerCase();
          const haystack = lowerName.replace(whitespaceRegex, '');
          if (haystack.includes(combinedNeedle)) {
            return true;
          }
          const wordsMatch = tokens.every(token => lowerName.includes(token));
          if (wordsMatch) {
            return true;
          }
        }

        if (!columnKeys.length || columnKeys.includes('sources')) {
          const sourceStrings = collectSourceStrings(category, nfrMap);
          if (sourceStrings.some(entry => entry.toLowerCase().replace(whitespaceRegex, '').includes(combinedNeedle))) {
            return true;
          }
          if (sourceStrings.some(entry => {
            const lowerEntry = entry.toLowerCase();
            return tokens.every(token => lowerEntry.includes(token));
          })) {
            return true;
          }
        }

        if (!columnKeys.length || columnKeys.includes('fuels')) {
          const fuelStrings = collectFuelStrings(category);
          if (fuelStrings.some(entry => entry.toLowerCase().replace(whitespaceRegex, '').includes(combinedNeedle))) {
            return true;
          }
          if (fuelStrings.some(entry => {
            const lowerEntry = entry.toLowerCase();
            return tokens.every(token => lowerEntry.includes(token));
          })) {
            return true;
          }
        }

        return false;
      }

      function renderCategoryTable(categoryList, options = {}) {
        const highlightRegex = options.highlightRegex || null;
        const selectedColumns = Array.isArray(options.selectedColumns)
          ? options.selectedColumns
          : ['name', 'sources', 'fuels'];
        const applyHighlightToAll = !selectedColumns.length;
        const nameHighlight = (applyHighlightToAll || selectedColumns.includes('name')) ? highlightRegex : null;
        const sourcesHighlight = (applyHighlightToAll || selectedColumns.includes('sources')) ? highlightRegex : null;
        const fuelHighlight = (applyHighlightToAll || selectedColumns.includes('fuels')) ? highlightRegex : null;
        const nfrLookup = categoryInfoState ? categoryInfoState.nfrMap : {};

        if (!Array.isArray(categoryList) || !categoryList.length) {
          contentEl.innerHTML = '<p class="text-sm text-gray-600">No categories match the current filter.</p>';
          scheduleHeightUpdate(40);
          return;
        }

        const copyMetadata = [];
        let tableHtml = `
          <table id="categoryTable" aria-label="NAEI category information">
            <thead>
              <tr>
                <th>Category Name</th>
                <th class="category-info-activity-column"><span class="category-info-activity-heading" aria-hidden="true">Activity<br>Data</span><span class="sr-only">Activity Data</span></th>
                <th>Sources</th>
                <th>Fuel Types (Activity in NAEI data)</th>
              </tr>
            </thead>
            <tbody>
        `;

        categoryList.forEach(category => {
          const activityInfo = getActivityIndicatorInfo(category);
          const sourcesHtml = formatSourcesCell(category, nfrLookup, sourcesHighlight);
          const fuelHtml = formatFuelCell(category, fuelHighlight);
          const sourcesPlainText = formatSourcesPlainText(category, nfrLookup);
          const fuelPlainText = formatFuelPlainText(category);
          const metadataIndex = copyMetadata.length;
          const activityStatus = activityInfo.message === 'Yes' ? 'Available' : 'Unavailable';
          copyMetadata.push({
            name: category.name || '',
            activityDescription: activityInfo.description || '',
            activityStatus,
            sources: sourcesPlainText,
            fuels: fuelPlainText
          });
          tableHtml += `
            <tr data-copy-index="${metadataIndex}">
              <td style="font-weight:600;" data-copy-text="${escapeHtml(category.name)}">${highlightText(category.name, nameHighlight)}</td>
              <td class="category-info-activity-cell" data-copy-text="${escapeHtml(activityInfo.description)}">
                <img src="${activityInfo.iconSrc}" alt="" class="category-info-activity-icon" width="24" height="24" loading="lazy">
                <span class="sr-only">${escapeHtml(activityInfo.description)}</span>
              </td>
              <td data-copy-text="${escapeHtml(sourcesPlainText)}">${sourcesHtml}</td>
              <td data-copy-text="${escapeHtml(fuelPlainText)}">${fuelHtml}</td>
            </tr>
          `;
        });

        tableHtml += '</tbody></table>';
        contentEl.innerHTML = tableHtml;

        const tableEl = contentEl.querySelector('table');
        attachCopyHandlers(tableEl, copyMetadata);
        scheduleHeightUpdate(60);
      }

      function applyCategoryFilters() {
        if (!categoryInfoState) {
          return;
        }

        const rawTerm = filterInput ? filterInput.value : '';
        const normalizedTerm = normalizeSearchTerm(rawTerm);
        const columnKeys = getSelectedColumnKeys();
        let filteredCategories;
        let highlightRegex = null;

        if (!columnKeys.length) {
          filteredCategories = categoryInfoState.categories.slice();
        } else {
          filteredCategories = categoryInfoState.categories.filter(category => matchesCategory(category, normalizedTerm, columnKeys, categoryInfoState.nfrMap));
          highlightRegex = createHighlightRegex(normalizedTerm);
        }

        renderCategoryTable(filteredCategories, {
          highlightRegex: columnKeys.length ? highlightRegex : null,
          selectedColumns: columnKeys
        });

        setFilterInputState(columnKeys.length > 0);
      }

      function handleColumnCheckboxChange(changedBox) {
        if (!changedBox) {
          return;
        }

        const allBox = columnCheckboxes.find(box => box.value === 'all');
        const dataBoxes = columnCheckboxes.filter(box => box.value !== 'all');

        if (changedBox.value === 'all') {
          const shouldCheck = changedBox.checked;
          dataBoxes.forEach(box => {
            box.checked = shouldCheck;
          });
        } else {
          if (allBox) {
            if (!changedBox.checked) {
              allBox.checked = false;
            } else {
              allBox.checked = dataBoxes.every(box => box.checked);
            }
          }
        }

        setFilterInputState(getSelectedColumnKeys().length > 0);
      }

      let filterControlsInitialized = false;
      const COPY_FEEDBACK_DURATION = 2200;
      const copyFeedbackTimers = new WeakMap();

      function showCopyFeedback(row) {
        if (!row) {
          return;
        }

        const cells = Array.from(row.cells || []);
        const nonActivityCells = cells.filter((_, index) => index !== 1);
        const smallestCellWidth = (() => {
          const widths = nonActivityCells
            .map(cell => {
              const rect = cell.getBoundingClientRect();
              return rect && rect.width ? rect.width : (cell.offsetWidth || 0);
            })
            .filter(value => value > 0);
          if (!widths.length) {
            return 120;
          }
          return Math.min(...widths);
        })();
        const copyFontSize = Math.max(18, Math.min(42, Math.floor(smallestCellWidth * 0.35)));
        if (copyFeedbackTimers.has(row)) {
          clearTimeout(copyFeedbackTimers.get(row));
          copyFeedbackTimers.delete(row);
          row.classList.remove('category-info-row-copying');
          nonActivityCells.forEach(cell => {
            const existingLabel = cell.querySelector('.category-info-copied-label');
            if (existingLabel) {
              existingLabel.classList.remove('is-visible');
            }
          });
        }

        row.classList.add('category-info-row-copying');

        nonActivityCells.forEach(cell => {
          let label = cell.querySelector('.category-info-copied-label');
          if (!label) {
            label = document.createElement('span');
            label.className = 'category-info-copied-label';
            label.textContent = 'Copied';
            cell.appendChild(label);
          }
          label.style.fontSize = `${copyFontSize}px`;
          label.classList.remove('is-visible');
          requestAnimationFrame(() => {
            label.classList.add('is-visible');
          });
        });

        const timeoutId = setTimeout(() => {
          row.classList.remove('category-info-row-copying');
          nonActivityCells.forEach(cell => {
            const label = cell.querySelector('.category-info-copied-label');
            if (label) {
              label.classList.remove('is-visible');
            }
          });
          copyFeedbackTimers.delete(row);
        }, COPY_FEEDBACK_DURATION);

        copyFeedbackTimers.set(row, timeoutId);
      }

      function setupFilterControls() {
        if (filterControlsInitialized) {
          return;
        }

        if (filterInput) {
          filterInput.addEventListener('input', () => {
            if (!isFilterInputActive()) return;
            applyCategoryFilters();
          });
          filterInput.addEventListener('search', () => {
            if (!isFilterInputActive()) return;
            applyCategoryFilters();
          });
        }

        columnCheckboxes.forEach(box => {
          box.addEventListener('change', event => {
            handleColumnCheckboxChange(event.currentTarget);
            applyCategoryFilters();
          });
        });

        setFilterInputState(getSelectedColumnKeys().length > 0);

        filterControlsInitialized = true;
      }

      function attachCopyHandlers(tableEl, metadata = []) {
        if (!tableEl) return;

        tableEl.addEventListener('click', event => {
          const row = event.target.closest('tbody tr');
          if (!row) return;

          let textToCopy = '';
          const metadataIndex = typeof row.dataset.copyIndex !== 'undefined' ? Number(row.dataset.copyIndex) : NaN;
          if (!Number.isNaN(metadataIndex) && metadata[metadataIndex]) {
            const rowMeta = metadata[metadataIndex];
            const lines = [
              'CATEGORY NAME',
              rowMeta.name || '',
              '',
              'ACTIVITY DATA',
              rowMeta.activityStatus || rowMeta.activityDescription || '',
              '',
              'SOURCES',
              rowMeta.sources || '',
              '',
              'FUEL TYPES',
              rowMeta.fuels || ''
            ];
            textToCopy = lines
              .join('\n')
              .replace(/\n{3,}/g, '\n\n')
              .trim();
          } else {
            textToCopy = Array.from(row.cells)
              .map(cell => {
                if (cell?.dataset?.copyText) {
                  return cell.dataset.copyText.trim();
                }
                return cell.innerText.trim();
              })
              .filter(Boolean)
              .join('\n\n');
          }

          if (!textToCopy) return;

          const successMessage = 'Copied category details to clipboard.';

          const onSuccess = () => {
            showCopyFeedback(row);
            setStatus(successMessage, false);
            scheduleHeightUpdate(20);
          };

          const fallbackCopy = () => {
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            textarea.setAttribute('readonly', '');
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            const selection = document.getSelection();
            const priorRange = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
            textarea.select();
            try {
              const ok = document.execCommand('copy');
              if (ok) {
                onSuccess();
              } else {
                console.warn('document.execCommand copy returned false');
              }
            } catch (error) {
              console.warn('Fallback copy failed:', error);
            }
            document.body.removeChild(textarea);
            if (priorRange && selection) {
              selection.removeAllRanges();
              selection.addRange(priorRange);
            }
          };

          if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
            navigator.clipboard.writeText(textToCopy)
              .then(onSuccess)
              .catch(error => {
                console.warn('navigator.clipboard.writeText failed:', error);
                fallbackCopy();
              });
          } else {
            fallbackCopy();
          }

          clearTimeout(statusTimer);
          statusTimer = setTimeout(() => {
            setStatus('', true);
          }, 3200);
        });
      }

      async function loadCategoryInfo() {
        showLoadingOverlay();

        const dataset = await ensureSharedDataLoaded();
        await ensureActDataStatus();

        let categoryRows = [];
        let nfrRows = [];

        try {
          if (dataset && Array.isArray(dataset.categories) && dataset.categories.length) {
            categoryRows = dataset.categories.slice();
          } else if (dataset && Array.isArray(dataset.groups) && dataset.groups.length) {
            categoryRows = dataset.groups.slice();
          } else {
            const loader = resolveSharedDataLoader();
            if (loader && loader.isDataLoaded?.()) {
              const cached = loader.getCachedData();
              if (cached?.categories?.length) {
                categoryRows = cached.categories.slice();
              } else if (cached?.groups?.length) {
                categoryRows = cached.groups.slice();
              }
              if (cached?.nfrCodes?.length) {
                nfrRows = cached.nfrCodes.slice();
              }
            }
          }
        } catch (error) {
          console.warn('Unable to access cached category information:', error);
        }

        if (!nfrRows.length && dataset?.nfrCodes?.length) {
          nfrRows = dataset.nfrCodes.slice();
        }

        if (!categoryRows.length) {
          contentEl.innerHTML = "<p class='text-red-600 font-semibold'>âš ï¸ Unable to load category information right now. Please try again later.</p>";
          setStatus('', true);
          hideLoadingOverlay();
          markInitialContentReady();
          scheduleHeightUpdate(140, { force: true, awaitInitialSettlement: true });
          scheduleHeightUpdate();
          return;
        }

        const { categories, nfrMap } = buildCategoryMaps(categoryRows, nfrRows);

        if (!categories.length) {
          contentEl.innerHTML = "<p class='text-red-600 font-semibold'>âš ï¸ No category information is available.</p>";
          setStatus('', true);
          hideLoadingOverlay();
          markInitialContentReady();
          scheduleHeightUpdate(140, { force: true, awaitInitialSettlement: true });
          scheduleHeightUpdate();
          return;
        }

        categoryInfoState = {
          categories,
          nfrMap
        };

        setupFilterControls();
        applyCategoryFilters();
        setStatus('', true);
        hideLoadingOverlay();
        markInitialContentReady();
        scheduleHeightUpdate(140, { force: true, awaitInitialSettlement: true });
        scheduleHeightUpdate(30);

        if (categoryInfoDatasetSource === 'direct-supabase') {
          requestSharedDatasetBootstrap('category-info-direct');
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        loadCategoryInfo().catch(error => {
          console.error('Failed to load category info page:', error);
          contentEl.innerHTML = "<p class='text-red-600 font-semibold'>âš ï¸ Something went wrong while loading category information.</p>";
          setStatus('', true);
          hideLoadingOverlay();
          markInitialContentReady();
          scheduleHeightUpdate(140, { force: true, awaitInitialSettlement: true });
          scheduleHeightUpdate();
        });
      });

      window.addEventListener('message', event => {
        if (event?.data?.type === 'requestHeight') {
          if (initialContentReady) {
            sendHeightToParent(true, { awaitInitialSettlement: true });
          } else {
            parentHeightRequestPending = true;
          }
        }
      });
    })();
  </script>
</body>
</html>
