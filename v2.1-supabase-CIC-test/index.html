<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NAEI Multi-Group Pollutant Viewer</title>
  <link rel="icon" type="image/png" sizes="64x64" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">

  <!-- Social preview / link preview meta tags -->
  <meta name="description" content="NAEI Multi-Group Pollutant Viewer">
  <!-- Open Graph (Facebook, LinkedIn, Slack, etc.) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="NAEI Multi-Group Pollutant Viewer">
  <meta property="og:description" content="Compare emissions from grouped NAEI sources across years. Interactive charts, CSV/XLSX export and downloadable images.">
  <meta property="og:url" content="https://github.com/Chronic-Illness-Channel/naei-multigroup-viewer">
  <meta property="og:image" content="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">
  <meta property="og:image:width" content="1120">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="NAEI Multi-Group Pollutant Viewer">
  <meta name="twitter:description" content="Compare emissions from grouped NAEI sources across years.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">
  <meta name="twitter:site" content="@Chronic_Channel">
  <meta name="twitter:creator" content="@Chronic_Channel">
  <!-- Legacy image hint -->
  <link rel="image_src" href="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  
  <script src="https://www.gstatic.com/charts/loader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; color: #000; background:#fff; }
    label { font-weight:600; margin-right:6px; }
    .title-row {
      position: relative;
      margin-bottom: 0;
    }
  #cicLogo {
    position: absolute;
    top: 0;
    right: 0;
    width: 110px;
    height: auto;
    max-width: none;
  }
	
    h2 { margin-bottom:8px; width: 100%; display: block; }

    /* Main title styling - keep desktop behaviour similar to V1 */
    .main-title {
      margin: 0 0 20px 0;
      padding-right: 140px;
      font-size: 26px;
      font-weight: 700;
      line-height: 1.3;
      white-space: normal;
      overflow-wrap: normal;
      text-align: left;
    }

    .main-title .title-part {
      display: inline;
      white-space: nowrap;
    }
    
    /* Mobile styles */
    @media (max-width: 768px) {
      body {
        margin: 15px;
      }
    }

    @media (max-width: 480px) {
      body {
        margin: 15px;
      }
    }

    @media (max-width: 700px) {
      .main-title {
        padding-right: 0;
      }

      .main-title .title-part-2 {
        display: block;
      }
    }
	
    select, button { margin:6px; padding:6px 10px; border-radius:6px; border:1px solid #ccc; }
    
    /* Ensure buttons match v1 styling exactly - force override */
    #downloadBtn, #toggleSmoothBtn, #downloadCSVBtn, #downloadXLSXBtn, #shareBtn, .add-btn, .remove-btn {
      background: #EFEFEF !important;
      cursor: pointer !important;
      margin: 6px !important;
      padding: 6px 10px !important;
      border-radius: 6px !important;
      border: 1px solid #ccc !important;
      font-family: system-ui, sans-serif !important;
      color: inherit !important;
    }
    
    #downloadBtn:hover, #toggleSmoothBtn:hover, #downloadCSVBtn:hover, #downloadXLSXBtn:hover, #shareBtn:hover, .add-btn:hover, .remove-btn:hover {
      background: #E0E0E0 !important;
    }
    
    /* Ensure select dropdowns match v1 styling exactly */
    select, #pollutantSelect, #startYear, #endYear, #groupContainer select {
      margin: 6px !important;
      padding: 6px 10px !important;
      border-radius: 6px !important;
      border: 1px solid #ccc !important;
      background: #fff !important;
      font-family: system-ui, sans-serif !important;
      color: inherit !important;
    }
    
    #groupContainer { margin-top:10px; }
    .groupRow { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .groupRow.dragging { opacity:0.5; }
    .dragHandle { cursor:grab; user-select:none; padding:4px 6px; background:#f0f0f0; border-radius:6px; }
    #chartTitle { font-weight:700; font-size:18px; margin-top:8px; margin-bottom:6px; text-align:center; }
  #chart_div { width:100%; height:60vh; margin-top:0; opacity:0; transition:opacity .35s ease; min-height:40vh; border:1px solid #eee; border-radius:6px; padding:6px; box-sizing:border-box; }
    #chart_div.visible { opacity:1; }
    button { background:#EFEFEF; cursor:pointer; }
    button:hover { background:#E0E0E0; }
    button:disabled { background:#EEE; color:#666; cursor:not-allowed; }
    .add-btn, .remove-btn { display:inline-flex; align-items:center; gap:6px; }
    .remove-icon { display:inline-block; width:18px; height:18px; border-radius:50%; background:#d33; color:#fff; text-align:center; line-height:18px; font-weight:bold; }
    .add-btn .add-icon { color:#4CAF50; font-weight:bold; font-size:2em; }
    .add-btn:hover .add-icon { color:#45a049; }
    #loadingOverlay { position:fixed; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:rgba(255,255,255,0.98); z-index:9999; transition:opacity .35s ease; }
    .spinner { width:72px; height:72px; border-radius:50%; background: conic-gradient(#E6194B 0deg 120deg,#F58231 120deg 240deg,#FFE119 240deg 360deg); animation:spin 1.25s linear infinite; box-shadow:0 0 12px rgba(0,0,0,0.08); }
    @keyframes spin { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
    .loading-text { margin-top:12px; color:#333; font-weight:600; }
  #mainContent { display:none; opacity:0; transition:opacity .4s ease; }
    #mainContent.loaded { opacity:1; }
    /* Fix cursor for clickable summary elements */
    details summary { cursor: pointer; user-select: none; }
    details summary::-webkit-details-marker { cursor: pointer; }
    /* Prevent text cursor only on non-text UI elements */
    .chart-container, #chart_div { cursor: default; user-select: none; }
    /* Ensure interactive elements have pointer cursor */
    button, .add-btn, .remove-btn, .dragHandle { cursor: pointer; user-select: none; }
    /* Use pointer cursor for interactive form elements */
    input, textarea, select { cursor: pointer; }
	/* --- Legend dot alignment fix --- */
	#customLegend {
	  margin-top: 10px;
	  display: flex;
	  flex-wrap: wrap;
	  justify-content: center;
	  align-items: center;
	  font-family: system-ui, sans-serif;
	  gap: 10px; /* space between legend items */
	}

	#customLegend span {
	  display: inline-flex;
	  align-items: center;     /* centers dot + text vertically */
	  gap: 4px;                /* tighter gap between dot and text */
	  margin: 4px 8px;         /* small spacing between items */
	  cursor: pointer;
	  font-weight: 600;
	  line-height: 1;
	  user-select: none;
	}

	#customLegend span > span {
	  width: 10px;             /* smaller dot */
	  height: 10px;
	  border-radius: 50%;
	  flex-shrink: 0;
	  transform: translateY(1px); /* tiny vertical optical fix */
	}
	
	/* --- Footer centering fix --- */
	footer {
	  width: 100%;
	  text-align: center;
	  font-size: 12px;
	  color: #555;
	  margin-top: 8px;
	  line-height: 1.4;
	  font-family: system-ui, sans-serif;
	}

	footer a {
	  color: #3366cc;
	  text-decoration: none;
	}

	footer a:hover {
	  text-decoration: underline;
	}
  
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner" aria-hidden="true"></div>
    <div class="loading-text">Loading data, please wait‚Ä¶</div>
  </div>

  <div id="mainContent" aria-hidden="true">
    <div class="title-row">
  <h2 class="main-title"><span class="title-part title-part-1">NAEI Multi-Group</span> <span class="title-part title-part-2">Pollutant Viewer</span></h2>
      <a href="https://www.youtube.com/@ChronicIllnessChannel" target="_blank" rel="noopener" style="cursor:pointer;">
        <img id="cicLogo" src="CIC - Square - Border - Words - Alpha 360x360.png" alt="CIC Logo">
      </a>
    </div>
<details class="my-4 bg-gray-50 border border-gray-300 rounded-2xl p-4 shadow-sm">
  <summary class="cursor-pointer text-lg font-semibold text-blue-700 hover:text-blue-900">
    üìò Quick Start Guide
  </summary>

  <div class="mt-3 space-y-3 text-gray-800 leading-relaxed">
    <p>
      <strong>Quick Start Guide:</strong> Select a <strong>pollutant</strong>, choose one or more <strong>groups</strong> to compare, set your <strong>year range</strong>, and view the interactive chart.
    </p>

 
    <h3 class="font-semibold text-blue-700">Essential Steps</h3>
    <p>
    <ol class="list-decimal list-inside space-y-2">
      <li><strong>Select Pollutant:</strong> Choose from PM2.5, NOx, CO‚ÇÇ, etc.</li>
      <li><strong>Add Groups:</strong> Compare emission sources like "Road Transport" vs "Power Stations"</li>
      <li><strong>Set Years:</strong> Focus on specific time periods (1970-2023 available)</li>
      <li><strong>Interact:</strong> Hover over chart points, click legend items to show/hide lines</li>
      <li><strong>Export & Share:</strong> Download images, export data, or share via URL</li>
    </ol>
<!-- 
    <div style="text-align: center; margin: 25px 0;">
      <a href="../help.html" 
         style="display: inline-block; background: #2196F3; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: 600; box-shadow: 0 2px 8px rgba(33,150,243,0.3);">
        üìñ View Complete User Guide
      </a>
    </div>

    <p style="font-size: 14px; color: #666; text-align: center;">
      Complete documentation covers sharing, exporting, group details, troubleshooting, and all advanced features.
 -->
  </div>
    <p>
      Click <strong>‚Äú+ Add Group‚Äù</strong> to add a new group comparison (e.g., Road Transport, Power Stations, Domestic Combustion).<br>
      You can add up to <strong>10 groups</strong> to compare at once.<br>
      To remove a group, click <strong>‚Äú‚àí Remove Group‚Äù</strong> next to it (this appears when two or more groups are selected).
    </p>
    <p class="italic text-sm text-gray-600">
      üí° Tip: You can re-order the group boxes by clicking and dragging the ‚†ø handle next to each group ‚Äî the chart updates automatically.
    </p>

    <h3 class="font-semibold text-blue-700">3Ô∏è‚É£ Set the Year Range</h3>
    <p>
      Use the <strong>Start Year</strong> and <strong>End Year</strong> dropdowns to focus on a particular time period.<br>
      The chart will automatically refresh to show data for the chosen range.
    </p>

    <h3 class="font-semibold text-blue-700">4Ô∏è‚É£ View and Interact with the Chart</h3>
    <p>
      Once you‚Äôve chosen your pollutant, groups, and years, the interactive line chart will appear.<br>
      <strong>Hover</strong> over any point on the chart to see the exact emission value for that year.<br>
      The <strong>Y-axis</strong> shows total emissions, including units (e.g., kilotonnes).<br>
      Each group is shown in a unique colour.
    </p>

    <h3 class="font-semibold text-blue-700">5Ô∏è‚É£ Use the Legend to Toggle Lines</h3>
    <p>
      Above the chart, the legend lists all groups and their corresponding colours.<br>
      <strong>Click a group name</strong> in the legend to hide or show that group‚Äôs line on the chart.<br>
      Faded items indicate hidden or unavailable data.<br>
      <em>(Groups labelled ‚Äú(No data available)‚Äù are included for reference but contain no plotted values.)</em>
    </p>

    <h3 class="font-semibold text-blue-700">6Ô∏è‚É£ Smooth or Straight Lines</h3>
    <p>
      Click the <strong>‚Äúüö´ Disable Smoothing‚Äù</strong> button to switch to straight (non-curved) lines.<br>
      Click again (the button will change to <strong>‚Äú‚úÖ Enable Smoothing‚Äù</strong>) to re-enable smooth, curved lines.
    </p>

<h3 class="font-semibold text-blue-700">7Ô∏è‚É£ Download Options</h3>
<p>You can export both the chart and its underlying data for your own analysis or reporting.</p>

<p>
  <strong>üìä Download Chart as PNG</strong><br>
  Click <strong>‚Äú‚¨áÔ∏è Download Chart as PNG‚Äù</strong> to save the current chart as an image.<br>
  The exported image includes:
  <ul class="list-disc list-inside ml-4">
    <li>The chart itself</li>
    <li>Custom colour legend</li>
    <li>Pollutant name and emission unit</li>

  </ul>
</p>

<p>
  <strong>üìÑ Download Data</strong><br>
  <strong>CSV:</strong> Click ‚ÄúüìÑ Download Data ‚Äì CSV‚Äù for a spreadsheet-friendly text file.<br>
  <strong>Excel:</strong> Click ‚Äúüìä Download Data ‚Äì Excel‚Äù for a formatted Excel workbook.<br>
  Each file includes:
  <ul class="list-disc list-inside ml-4">
    <li>Pollutant name and emission unit in the first line</li>
    <li>Table with groups as rows and years as columns</li>
    <li>Footer row with download timestamp</li>
  </ul>
</p>

<h3 class="font-semibold text-blue-700">8Ô∏è‚É£ Share Your Chart</h3>
<p>
  Click the <strong>Share</strong> button to copy a unique link or chart image.<br>
  You can easily share your current view with others, or paste the chart image into emails and documents.<br>
  The shared link will open the viewer with your selected pollutant, groups, and year range.
</p>

<h3 class="font-semibold text-blue-700">9Ô∏è‚É£ View Group Details</h3>
<p>
  Use the <strong>‚Äúüìò See Group Info‚Äù</strong> section below the group selector to view details of how each group is built.<br>
  The table shows <strong>Source Names</strong> and <strong>Fuel Types</strong> from the NAEI data that have been combined to create each group.<br>
  If a group includes all sources or all fuel types, these will be shown as <em>‚ÄúAll Sources‚Äù</em> or <em>‚ÄúAll Fuel Types‚Äù</em>.
</p>

<h3 class="font-semibold text-blue-700">üîü Licensing and Attribution</h3>
<p>
  ¬© Crown copyright (Defra & DESNZ) and available under the
  <strong>Open Government Licence (OGL)</strong>.<br>
  See links beneath the chart for full details.
</p>
</details>

    <div>
      <label for="pollutantSelect">Pollutant:</label>
  <select id="pollutantSelect" name="pollutantSelect"><option value="">Select pollutant</option></select>
    </div>

    <div id="groupContainer"></div>

<details class="my-4 bg-gray-50 border border-gray-300 rounded-2xl p-4 shadow-sm">
  <summary class="cursor-pointer text-lg font-semibold text-blue-700 hover:text-blue-900">
    üìò See Group Info
  </summary>

  <div id="group-info" class="mt-3 text-gray-800 leading-relaxed overflow-x-auto">
    <p>Loading group information...</p>
  </div>
</details>

    <div>
      <label for="startYear">Start Year:</label>
  <select id="startYear" name="startYear"></select>

      <label for="endYear">End Year:</label>
  <select id="endYear" name="endYear"></select>

      <button id="downloadBtn">‚¨áÔ∏è Download Chart as PNG</button>
	  <button id="toggleSmoothBtn">üö´ Disable Smoothing</button>
	  <button id="downloadCSVBtn">üìÑ Download Data - CSV</button>
	  <button id="downloadXLSXBtn">üìä Download Data - Excel</button>
	  <button id="shareBtn">üîó Share Chart</button>
	  
    </div>

    <div id="chartTitle" aria-hidden="true"></div>
    <div id="customLegend" aria-hidden="true"></div>
    <div id="chart_div" role="img" aria-label="Pollutant time series chart"></div>
<footer>
  ¬© Crown 2025 copyright Defra &amp; DESNZ via 
  <a href="https://naei.energysecurity.gov.uk" target="_blank" rel="noopener">naei.energysecurity.gov.uk</a> 
  licensed under the <a href="http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" target="_blank" rel="noopener">Open Government Licence (OGL)</a>.
  <br>
  <strong>YouTube Channel:</strong> <a href="https://www.youtube.com/@ChronicIllnessChannel" target="_blank" rel="noopener">www.youtube.com/@ChronicIllnessChannel</a>
  <br>
  <span style="font-size: 0.8em; color: #666; margin-top: 4px; display: inline-block;">
    Version: v2.0 (Supabase) ‚Ä¢ Build: 2025.10.23
  </span>
</footer>

  </div>

<script>
google.charts.load('current', {packages:['corechart']});

// Supabase project connection
const SUPABASE_URL = 'https://vhplzwzzkeueyelaqftl.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZocGx6d3p6a2V1ZXllbGFxZnRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0NjQwODUsImV4cCI6MjA3NjA0MDA4NX0.mBAwFmfSpqffvp1GGDHKvp-y_hukSZmF4GN-Ghnf--o';
const supabase = (window.supabase && window.supabase.createClient)
  ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
  : null;
let supabaseUnavailableLogged = false;

// Analytics tracking
let sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
let userFingerprint = null;
let userCountry = null;

// Get user's country (privacy-friendly timezone method)
function getUserCountry() {
  if (userCountry) return userCountry;
  
  try {
    // Get timezone and map to likely country
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const locale = navigator.language || 'en';
    
    // Simple mapping for common cases (privacy-friendly approach)
    const timezoneCountryMap = {
      'Europe/London': 'GB',
      'America/New_York': 'US', 'America/Chicago': 'US', 'America/Denver': 'US', 'America/Los_Angeles': 'US',
      'Europe/Paris': 'FR', 'Europe/Berlin': 'DE', 'Europe/Rome': 'IT', 'Europe/Madrid': 'ES',
      'Asia/Tokyo': 'JP', 'Asia/Shanghai': 'CN', 'Asia/Kolkata': 'IN',
      'Australia/Sydney': 'AU', 'Australia/Melbourne': 'AU',
      'America/Toronto': 'CA', 'America/Vancouver': 'CA'
    };
    
    userCountry = timezoneCountryMap[timezone] || locale.split('-')[1] || 'Unknown';
    return userCountry;
  } catch (e) {
    return 'Unknown';
  }
}

// Generate a privacy-friendly user fingerprint
function generateUserFingerprint() {
  if (userFingerprint) return userFingerprint;

  // Get or create persistent UUID for this browser
  let uuid = localStorage.getItem('naei_analytics_uuid');
  if (!uuid) {
    uuid = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
    localStorage.setItem('naei_analytics_uuid', uuid);
  }

  // Collect non-invasive browser info for analytics
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top';
  ctx.font = '14px Arial';
  ctx.fillText('Browser fingerprint', 2, 2);
  const canvasData = canvas.toDataURL();

  const fingerprint = [
    uuid,
    navigator.userAgent,
    navigator.language,
    screen.width + 'x' + screen.height,
    new Date().getTimezoneOffset(),
    canvasData.slice(-50)
  ].join('|');

  // Hash it for privacy
  userFingerprint = btoa(fingerprint).substr(0, 24); // Slightly longer for more uniqueness
  return userFingerprint;
}

// Track analytics events
async function trackAnalytics(eventType, eventData = {}) {
  try {
    if (!eventType) return;

    if (!supabase) {
      if (!supabaseUnavailableLogged) {
        console.warn('Supabase client unavailable; analytics events will be skipped.');
        supabaseUnavailableLogged = true;
      }
      return;
    }

    const analyticsData = {
      session_id: sessionId,
      user_fingerprint: generateUserFingerprint(),
      event_type: eventType,
      event_data: {
        ...eventData,
        country: getUserCountry()
      },
      timestamp: new Date().toISOString(),
      user_agent: navigator.userAgent,
      page_url: window.location.href,
      referrer: document.referrer || null
    };

    console.log('üìä Analytics:', eventType, eventData);

    const { error } = await supabase
      .from('analytics_events')
      .insert([analyticsData]);

    if (error && !error.message?.includes('relation "analytics_events" does not exist')) {
      console.warn('Analytics tracking failed:', error);
    }
  } catch (err) {
    console.warn('Analytics error:', err);
  }
}

let globalRows=[], globalHeaders=[], pollutantUnits={}, groupedData={};
let allGroupsList = [];
let allPollutants = [];
let allGroups = [];
let pollutantsData = []; // Store raw pollutant data for ID lookups
let groupsData = []; // Store raw group data for ID lookups

const distinctPalette=['#E6194B','#3CB44B','#FFE119','#4363D8','#F58231','#911EB4','#46F0F0','#F032E6','#BCF60C','#FABEBE'];
const categoryBaseColor={ecodesign:distinctPalette[4],fireplace:distinctPalette[0],gas:distinctPalette[3],power:distinctPalette[1],road:distinctPalette[6]};
let colorCache={}, availableColors=[...distinctPalette];
let chart; // global chart instance
let smoothLines = true; // default to smooth (curved) lines


/* ---------------- Color helpers ---------------- */
function resetColorSystem() {
  colorCache = {};
  availableColors = [...distinctPalette];
}

function getColorForGroup(name) {
  if (!name) return '#888888';
  if (colorCache[name]) return colorCache[name];

  const lower = name.toLowerCase();
  const cat = Object.keys(categoryBaseColor).find(c => lower.includes(c));

  // Prefer category colour if available
  let baseColor = cat ? categoryBaseColor[cat] : null;
  let chosenColor = baseColor;

  // Avoid duplicates: if base colour already used, pick next available
  if (!chosenColor || Object.values(colorCache).includes(chosenColor)) {
    chosenColor = availableColors.find(c => !Object.values(colorCache).includes(c));
  }

  // Fallback to any colour if palette exhausted (shouldn't happen with ‚â§10)
  if (!chosenColor) {
    chosenColor = distinctPalette[Object.keys(colorCache).length % distinctPalette.length];
  }

  colorCache[name] = chosenColor;
  return chosenColor;
}


// --- Replace Google Sheets data load with Supabase ---
async function loadUnits() {
  const { data, error } = await supabase.from('NAEI_global_Pollutants').select('*');
  if (error) throw error;
  pollutantUnits = {};
  data.forEach(r => {
    if (r.Pollutant && r["Emission Unit"]) {
      pollutantUnits[r.Pollutant] = r["Emission Unit"];
    } else if (r.pollutant) {
      pollutantUnits[r.pollutant] = r["emission unit"] || r['Emission Unit'] || '';
    }
  });
}

async function loadData() {
  console.log("Fetching data from Supabase (separate tables for robustness)...");

  // Fetch pollutants, groups, and the timeseries table separately.
  const [pollutantsResp, groupsResp, dataResp] = await Promise.all([
    supabase.from('NAEI_global_Pollutants').select('*'),
    supabase.from('NAEI_global_t_Group').select('*'),
    supabase.from('NAEI_2023ds_t_Group_Data').select('*')  // Now fetches all rows due to project setting
  ]);

  if (pollutantsResp.error) throw pollutantsResp.error;
  if (groupsResp.error) throw groupsResp.error;
  if (dataResp.error) throw dataResp.error;

  const pollutants = pollutantsResp.data || [];
  const groups = groupsResp.data || [];
  const rows = dataResp.data || [];
  
  // Store globally for URL parameter lookups
  pollutantsData = pollutants;
  groupsData = groups;

  // Build ID -> name maps for joins
  const pollutantIdToName = {};
  pollutants.forEach(p => {
    const id = p.id;
    const name = p.Pollutant || p.pollutant || p['Pollutant'] || p['pollutant'];
    if (name) {
      pollutantIdToName[id] = name;
      // capture unit if present
      const unit = p["Emission Unit"] || p["emission unit"] || p['Emission Unit'] || p.emission_unit || '';
      if (unit) pollutantUnits[name] = unit;
    }
  });

  const groupIdToTitle = {};
  groups.forEach(g => {
    const id = g.id;
    const title = g.Group_Title || g.group_title || g['Group_Title'] || g.group_title;
    if (title) groupIdToTitle[id] = title;
  });
  


  // Build lists used for dropdowns
  allPollutants = [...new Set(Object.values(pollutantIdToName).filter(Boolean))].sort();
  allGroups = [...new Set(Object.values(groupIdToTitle).filter(Boolean))].sort((a, b) => {
    if (a.toLowerCase() === "all") return -1;
    if (b.toLowerCase() === "all") return 1;
    return a.localeCompare(b);
  });

  window.allGroupsList = allGroups;
  window.allPollutants = allPollutants;

  // Determine year headers from data rows (look for fYYYY fields)
  if (!rows || rows.length === 0) {
    // no timeseries rows ‚Äî still return groups/pollutants for dropdowns
    window.globalHeaders = [];
    window.globalYears = [];
    window.globalYearKeys = [];
    groupedData = {};
    console.log('No timeseries rows found in NAEI_2023ds_t_Group_Data');
    return;
  }

  // ensure consistent header ordering (f1970 ... f2023)
  const sample = rows[0];
  const headers = Object.keys(sample).filter(k => /^f\d{4}$/.test(k)).sort((a,b)=> +a.slice(1) - +b.slice(1));
  window.globalHeaders = headers;
  window.globalYears = headers.map(h => h.slice(1));
  window.globalYearKeys = headers;

  // Build groupedData using FK ids and the lookup maps
  groupedData = {};
  rows.forEach(r => {
    const polId = r.Pollutant_id ?? r.pollutant_id ?? r.PollutantId ?? r.pollutantid;
    const grpId = r.Group_id ?? r.group_id ?? r.GroupId ?? r.groupid;
    const polName = pollutantIdToName[polId];
    const grpName = groupIdToTitle[grpId];
    if (!polName || !grpName) return;
    if (!groupedData[polName]) groupedData[polName] = {};
    groupedData[polName][grpName] = r;
  });

  // If the groups table didn't provide titles (or permissions prevented access), fall back to groups
  // discovered in the timeseries rows themselves
  const groupsFromData = [...new Set(Object.values(groupedData).flatMap(pol => Object.keys(pol)))];
  if ((!allGroups || allGroups.length === 0) && groupsFromData.length) {
    allGroups = groupsFromData.sort((a, b) => {
      if (a.toLowerCase() === "all") return -1;
      if (b.toLowerCase() === "all") return 1;
      return a.localeCompare(b);
    });
    window.allGroupsList = allGroups;
    console.warn('Groups list was empty from NAEI_global_t_Group ‚Äî falling back to groups found in timeseries rows.');
  }

  console.log(`Loaded ${rows.length} timeseries rows; ${allPollutants.length} pollutants; ${allGroups.length} groups`);
}


/* ---------------- UI: selectors & group controls ---------------- */
function setupSelectors(){
  // ‚úÖ Use pollutant list from Supabase loadData
  const sel = document.getElementById('pollutantSelect');
  sel.innerHTML = '<option value="">Select pollutant</option>';
  if (window.allPollutants && window.allPollutants.length) {
    window.allPollutants.forEach(p => sel.add(new Option(p, p)));
  }

  // Ensure we have the groups list available from the global window var
  if (!window.allGroupsList && window.allGroups) {
    window.allGroupsList = window.allGroups;
  }


  // ‚úÖ Use precomputed globalYears instead of header slice
  const years = window.globalYears || [];
  const startSel = document.getElementById('startYear');
  const endSel = document.getElementById('endYear');

  startSel.innerHTML = '';
  endSel.innerHTML = '';

  years.forEach(y => {
    startSel.add(new Option(y, y));
    endSel.add(new Option(y, y));
  });

  startSel.value = years[0] || '';
  endSel.value = years[years.length - 1] || '';

  sel.addEventListener('change', updateChart);
  startSel.addEventListener('change', updateChart);
  endSel.addEventListener('change', updateChart);

  // Group selectors will be added by the init() function after URL parameter processing
  // This prevents double group creation that causes visual jumping
 }

function getSelectedGroups(){ return [...document.querySelectorAll('#groupContainer select')].map(s => s.value).filter(Boolean); }
function addGroupSelector(defaultValue = "", usePlaceholder = true){
  const container = document.getElementById('groupContainer');
  const div = document.createElement('div');
  div.className = 'groupRow';
  div.draggable = true;

  // drag handle
  const dragHandle = document.createElement('span');
  dragHandle.className = 'dragHandle';
  dragHandle.textContent = '‚†ø';
  dragHandle.style.marginRight = '6px';
  div.appendChild(dragHandle);

  // group select
  const sel = document.createElement('select');
  sel.name = 'groupSelector';
  if (usePlaceholder){
    const ph = new Option('Select group','');
    ph.disabled = true; ph.selected = true;
    sel.add(ph);
  }
  const allGroups = window.allGroupsList || [];

  const selected = getSelectedGroups();
  allGroups.forEach(g => {
    if (!selected.includes(g) || g === defaultValue) sel.add(new Option(g,g));
  });
  if (defaultValue) sel.value = defaultValue;
  sel.addEventListener('change', () => { refreshGroupDropdowns(); updateChart(); });

  div.appendChild(sel);

  container.appendChild(div);
  addDragAndDropHandlers(div);
  refreshButtons();
}

function refreshGroupDropdowns(){
  const selected = getSelectedGroups();
  const all = window.allGroupsList || [];


  document.querySelectorAll('#groupContainer select').forEach(select => {
    const current = select.value;
    Array.from(select.options).forEach(opt => { if (opt.value !== '') opt.remove(); });
    all.forEach(g => {
      if (!selected.includes(g) || g === current) {
        const option = new Option(g,g);
        if (g === current) option.selected = true;
        select.add(option);
      }
    });
  });
}

function refreshButtons() {
  const container = document.getElementById('groupContainer');
  // Remove any existing Add/Remove buttons to rebuild cleanly
  container.querySelectorAll('.add-btn, .remove-btn').forEach(n => n.remove());

  const rows = container.querySelectorAll('.groupRow');

  // Add remove buttons only if there are 2 or more groups
  if (rows.length >= 2) {
    rows.forEach(row => {
      if (!row.querySelector('.remove-btn')) {
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerHTML = '<span class="remove-icon">‚àí</span> Remove Group';
        removeBtn.onclick = () => {
          row.remove();
          refreshButtons();
          refreshGroupDropdowns();
          updateChart();
        };
        row.appendChild(removeBtn);
      }
    });
  }

  // Add "Add Group" button just below the last group box
  let addBtn = container.querySelector('.add-btn');
  if (!addBtn) {
    addBtn = document.createElement('button');
    addBtn.className = 'add-btn';
    addBtn.innerHTML = '<span class="add-icon">+</span> Add Group';
    addBtn.onclick = () => addGroupSelector("", true);
    container.appendChild(addBtn);
  }

  // Disable button if 10 groups are present
  if (rows.length >= 10) {
    addBtn.textContent = 'Max Groups = 10';
    addBtn.disabled = true;
  } else {
    addBtn.innerHTML = '<span class="add-icon">+</span> Add Group';
    addBtn.disabled = false;
  }
}

function calculateYearTicks(years, chartWidth) {
  if (!years || !years.length) return [];

  const uniqueYears = [...new Set(years.map(y => String(y)))];
  if (!uniqueYears.length) return [];

  const firstYear = uniqueYears[0];
  const lastYear = uniqueYears[uniqueYears.length - 1];

  if (uniqueYears.length <= 2) {
    return uniqueYears.map(y => y);
  }

  const maxTicks = chartWidth < 480 ? 4 : chartWidth < 720 ? 6 : 10;
  if (uniqueYears.length <= maxTicks) {
    return uniqueYears.map(y => y);
  }

  const middleYears = uniqueYears.slice(1, -1);
  const step = Math.max(1, Math.ceil(middleYears.length / (maxTicks - 2)));
  const ticks = [firstYear];

  for (let i = 0; i < middleYears.length; i += step) {
    ticks.push(middleYears[i]);
  }

  if (ticks[ticks.length - 1] !== lastYear) {
    ticks.push(lastYear);
  }

  return ticks.map(y => y);
}

/* ---------------- Drag and drop handlers ---------------- */
function addDragAndDropHandlers(div){
  div.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', '');
    div.classList.add('dragging');
  });
  div.addEventListener('dragend', () => div.classList.remove('dragging'));
  div.addEventListener('dragover', e => {
    e.preventDefault();
    const container = document.getElementById('groupContainer');
    const dragging = container.querySelector('.dragging');
    if (!dragging) return;
    const after = getDragAfterElement(container, e.clientY);
    const addBtn = container.querySelector('.add-btn');
    if (!after || after === addBtn) container.insertBefore(dragging, addBtn);
    else container.insertBefore(dragging, after);
  });
  div.addEventListener('drop', () => { refreshGroupDropdowns(); updateChart(); });
}

function getDragAfterElement(container, y){
  const draggable = [...container.querySelectorAll('.groupRow:not(.dragging)')];
  return draggable.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
    return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

/* ---------------- Chart rendering & legend ---------------- */
function updateChart(){
  const pollutant = document.getElementById('pollutantSelect').value;
  const startYear = +document.getElementById('startYear').value;
  const endYear = +document.getElementById('endYear').value;
  const groups = getSelectedGroups();
  if (!pollutant || !startYear || !endYear || !groups.length) return;

  // Track chart view analytics
  trackAnalytics('chart_view', {
    pollutant: pollutant,
    start_year: startYear,
    end_year: endYear,
    groups: groups,
    groups_count: groups.length,
    year_range: endYear - startYear + 1
  });

  resetColorSystem();
  // Use the global year keys to determine which years to display
  const yearsAll = window.globalYears || [];
  const yearKeys = window.globalYearKeys || [];
  const startIdx = yearsAll.indexOf(String(startYear));
  const endIdx = yearsAll.indexOf(String(endYear));
  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) return;
  const years = yearsAll.slice(startIdx, endIdx + 1);
  const keysForYears = yearKeys.slice(startIdx, endIdx + 1);
  const colors = groups.map(g => getColorForGroup(g));

  // Build rows of data (year + series values). Use null for missing.
  const chartRows = years.map((y, rowIdx) => {
    const row = [y];
    const key = keysForYears[rowIdx]; // e.g. 'f2015'
    groups.forEach(g => {
      const dataRow = groupedData[pollutant]?.[g];
      const raw = dataRow ? dataRow[key] : null;
      const val = (raw === null || raw === undefined) ? null : parseFloat(raw);
      row.push(Number.isNaN(val) ? null : val);
    });
    return row;
  });

  // guard against empty data
  if (chartRows.length === 0) return;

  // --- Determine which groups actually have data ---
  const groupHasData = groups.map((g, i) => {
    return chartRows.some(row => typeof row[i + 1] === 'number');
  });

  // Create DataTable explicitly to guarantee column types
  const dataTable = new google.visualization.DataTable();
  dataTable.addColumn('string', 'Year');           // year as string
  groups.forEach(g => dataTable.addColumn('number', g)); // explicit numeric series columns
  dataTable.addRows(chartRows);

  const unit = pollutantUnits[pollutant] || "";
  const seriesOptions = {};
  groups.forEach((g, i) => {
    seriesOptions[i] = { color: colors[i], lineWidth: 3, pointSize: 4 };
  });

  // Estimate left margin dynamically based on Y-axis label width
  const maxValue = Math.max(
    ...chartRows.flatMap(r => r.slice(1).filter(v => typeof v === "number"))
  );
  const labelLength = maxValue ? maxValue.toLocaleString().length : 3;
  const leftMargin = Math.min(100, Math.max(60, labelLength * 10)); // dynamic left padding

  const chartContainer = document.getElementById('chart_div');

  const options = {
    title: '',
    width: '100%',
    height: '70%',
    legend: 'none',
    hAxis: {
      title: 'Year',
      textStyle: { fontSize: 12 },
      titleTextStyle: { fontSize: 13, bold: true }
    },
    vAxis: {
      title: `Emissions${unit ? " (" + unit + ")" : ""}`,
      viewWindow: { min: 0 },
      textStyle: { fontSize: 12 },
      titleTextStyle: { fontSize: 13, bold: true }
    },
    series: seriesOptions,
    curveType: smoothLines ? 'function' : 'none',
    lineWidth: 3,
    pointSize: 4,
    chartArea: {
      top: 20,
      left: leftMargin,
      right: 20,
      bottom: 60,
      width: '85%',
      height: '70%'
    }
  };
  

  // draw chart and show pollutant as visible page title
  chart = new google.visualization.LineChart(chartContainer);

  // Compute safe width/height to avoid negative SVG dimensions
  const safeWidth = Math.max(chartContainer.offsetWidth || 0, 300);
  const safeHeight = Math.max(chartContainer.offsetHeight || 0, 200);
  options.width = safeWidth;
  options.height = safeHeight;

  let yearTicks = calculateYearTicks(years, safeWidth);
  // Always include the first and last year in the ticks
  if (years.length && yearTicks.length) {
    if (yearTicks[0] !== years[0]) yearTicks.unshift(years[0]);
    if (yearTicks[yearTicks.length - 1] !== years[years.length - 1]) yearTicks.push(years[years.length - 1]);
  }
  // Remove duplicates, preserve order
  yearTicks = yearTicks.filter((y, i) => yearTicks.indexOf(y) === i);
  // On mobile, show only first, middle, last year for clarity
  const isMobile = window.innerWidth < 600;
  if (isMobile && years.length >= 2) {
    yearTicks = [years[0], years[years.length-1]];
  }
  // Add a trailing empty tick to force space for last year label
  if (yearTicks.length) {
    yearTicks.push('');
  }
  if (yearTicks.length && yearTicks.slice(0,-1).every(y => y === '' || years.includes(y))) {
    options.hAxis.ticks = yearTicks.map(y => String(y));
    // Always use vertical labels for mobile/small screens
    if (isMobile) {
      options.hAxis.slantedText = true;
      options.hAxis.slantedTextAngle = 90;
    } else {
      options.hAxis.slantedText = false;
      delete options.hAxis.slantedTextAngle;
    }
  }
  // Maximize right chart padding to ensure last label is visible
  if (options.chartArea) {
    options.chartArea.right = Math.max(options.chartArea.right || 20, 120);
    if (isMobile) {
      options.chartArea.width = '70%';
    }
  }

  // Delay slightly to let layout stabilize (prevents negative sizes)
  setTimeout(() => {
    chart.draw(dataTable, options);
    chartContainer.classList.add('visible');
  }, 100);

  // update visible title on page
  const titleEl = document.getElementById('chartTitle');
  titleEl.textContent = `${pollutant}${unit ? " (" + unit + ")" : ""}`;

  // build custom legend (interactive)
  const legendDiv = document.getElementById('customLegend');
  legendDiv.innerHTML = '';
  const seriesVisibility = Array(groups.length).fill(true);

  groups.forEach((g, i) => {
    const item = document.createElement('span');
    const dot = document.createElement('span');
    dot.style.display = 'inline-block';
    dot.style.width = '12px';
    dot.style.height = '12px';
    dot.style.borderRadius = '50%';
    dot.style.backgroundColor = colors[i];
    item.appendChild(dot);

    const labelText = document.createTextNode(g + (groupHasData[i] ? '' : ' (No data available)'));
    item.appendChild(labelText);

    // Fade if no data
    if (!groupHasData[i]) {
      item.style.opacity = '0.4';
      item.title = 'No data available';
    }

    // Toggle visibility only if data exists
    if (groupHasData[i]) {
      item.addEventListener('click', () => {
        seriesVisibility[i] = !seriesVisibility[i];
        const newOptions = { ...options, series: {} };
        groups.forEach((g2, idx) => {
          newOptions.series[idx] = seriesVisibility[idx]
            ? { color: colors[idx], lineWidth: 3, pointSize: 4 }
            : { color: colors[idx], lineWidth: 0, pointSize: 0 };
        });
        chart.draw(dataTable, newOptions);
        item.style.opacity = seriesVisibility[i] ? '1' : '0.4';
      });
    }

    legendDiv.appendChild(item);
  });

  // ensure controls reflect available choices
  refreshGroupDropdowns();
  refreshButtons();
}

window.addEventListener('resize', () => {
  clearTimeout(window._resizeTimer);
  window._resizeTimer = setTimeout(updateChart, 200);
});

async function renderInitialView() {
  return new Promise(resolve => {
    requestAnimationFrame(() => {
      try {
        updateChart();
      } catch (err) {
        console.error('Initial chart render failed:', err);
      } finally {
        setTimeout(resolve, 350);
      }
    });
  });
}

async function revealMainContent() {
  const overlay = document.getElementById('loadingOverlay');
  const content = document.getElementById('mainContent');
  if (!overlay || !content) return;

  content.style.display = 'block';
  content.removeAttribute('aria-hidden');
  requestAnimationFrame(() => content.classList.add('loaded'));

  await renderInitialView();

  overlay.style.opacity = '0';

  return new Promise(resolve => {
    setTimeout(() => {
      overlay.style.display = 'none';
      resolve();
    }, 400);
  });
}

function setupDownloadButton() {
  const dl = document.getElementById('downloadBtn');

  dl.addEventListener('click', () => {
    const pollutant = document.getElementById('pollutantSelect').value;
    if (!chart || !pollutant) return;

    // Track chart download analytics
    const selectedGroups = getSelectedGroups();
    const startYear = +document.getElementById('startYear').value;
    const endYear = +document.getElementById('endYear').value;
    trackAnalytics('chart_download', {
      pollutant: pollutant,
      start_year: startYear,
      end_year: endYear,
      groups: selectedGroups,
      groups_count: selectedGroups.length,
      filename: pollutant.replace(/[^a-z0-9_\-]/gi, '_') + '_comparison.png'
    });

    const unit = pollutantUnits[pollutant] || "";
    const imageURI = chart.getImageURI();
    const img = new Image();
    img.crossOrigin = 'anonymous';

    img.onload = () => {
      // --- Measure legend for layout ---
      const legendClone = document.getElementById('customLegend').cloneNode(true);
      legendClone.style.position = 'absolute';
      legendClone.style.visibility = 'hidden';
      legendClone.style.width = Math.min(800, img.width) + 'px';
      document.body.appendChild(legendClone);
      const legendHeight = legendClone.offsetHeight + 10;
      document.body.removeChild(legendClone);

      const titleHeight = 30;
      const footerHeight = 40;
      const padding = 20;

      // --- Determine output size ---
      const unscaledWidth = img.width + padding * 2;
      const unscaledHeight =
        img.height + titleHeight + legendHeight + footerHeight + padding * 3;

      // --- Auto-scale for print quality ---
      // For A4 landscape at 300 DPI: 3508 px wide
      const targetWidth = 3508;
      const scale = Math.max(
        window.devicePixelRatio || 1,
        targetWidth / unscaledWidth
      );

      const canvas = document.createElement('canvas');
      canvas.width = unscaledWidth * scale;
      canvas.height = unscaledHeight * scale;
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      // --- Background ---
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, unscaledWidth, unscaledHeight);

      // --- Title ---
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'center';
      ctx.fillText(
        `${pollutant}${unit ? " (" + unit + ")" : ""}`,
        unscaledWidth / 2,
        padding + 15
      );

      // --- Legend ---
      const legendDiv = document.getElementById('customLegend');
      const items = [...legendDiv.querySelectorAll('span')];
      let legendY = padding + 35;
      const legendRowHeight = 22;
      const maxW = unscaledWidth - padding * 2;
      const rowItems = [];
      let row = [],
        rowW = 0;

      items.forEach((it) => {
        const dot = it.querySelector('span');
        if (!dot) return;
        const text = it.textContent.trim();
        ctx.font = '600 14px system-ui, sans-serif';
        const textW = ctx.measureText(text).width;
        const w = textW + 40;
        if (rowW + w > maxW && row.length) {
          rowItems.push({ row, rowW });
          row = [];
          rowW = 0;
        }
        row.push({ dotColor: dot.style.backgroundColor, text });
        rowW += w;
      });

      if (row.length) rowItems.push({ row, rowW });

      rowItems.forEach(({ row, rowW }) => {
        let x = (unscaledWidth - rowW) / 2;
	row.forEach(({ dotColor, text }) => {
	  const faded = text.includes('(No data available)');
	  ctx.globalAlpha = faded ? 0.4 : 1.0;
	  ctx.beginPath();
	  ctx.arc(x + 6, legendY - 5, 6, 0, 2 * Math.PI);
	  ctx.fillStyle = dotColor;
	  ctx.fill();
	  ctx.font = '600 14px system-ui, sans-serif';
	  ctx.fillStyle = '#000000';
	  ctx.textAlign = 'left';
	  ctx.fillText(text, x + 18, legendY);
	  ctx.globalAlpha = 1.0;
	  x += ctx.measureText(text).width + 40;
	});
        legendY += legendRowHeight;
      });

      // --- Chart image ---
      ctx.drawImage(img, padding, legendY + 10);

      // --- Logo and footer ---
      const logo = new Image();
      logo.crossOrigin = 'anonymous'; // Allow CORS for canvas export
      logo.src = 'CIC - Square - Border - Words - Alpha 360x360.png';

      const finishExport = () => {
        const footerText =
          "¬© Crown 2025 copyright Defra & DESNZ via naei.energysecurity.gov.uk licensed under the Open Government Licence (OGL).";
        const channelText = "Youtube Channel: youtube.com/@chronicillnesschannel";
        const timestamp = new Date().toISOString().replace("T", " ").substring(0, 19);

        // --- Footer text wrapping ---
        ctx.font = '12px system-ui, sans-serif';
        ctx.fillStyle = '#555';
        ctx.textAlign = 'center';
        const maxFooterWidth = unscaledWidth - 40;
        function wrapText(text, maxWidth) {
          const words = text.split(' ');
          let lines = [], line = '';
          for (let n = 0; n < words.length; n++) {
            const testLine = line + (line ? ' ' : '') + words[n];
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && line) {
              lines.push(line);
              line = words[n];
            } else {
              line = testLine;
            }
          }
          if (line) lines.push(line);
          return lines;
        }
        const footerLines = wrapText(footerText, maxFooterWidth);
        let footerY = legendY + img.height + 20;
        footerLines.forEach((line, i) => {
          ctx.fillText(line, unscaledWidth / 2, footerY + i * 16);
        });
        footerY += footerLines.length * 16;

        // Draw YouTube channel with bold label, also wrapped if needed
        const boldText = "Youtube Channel: ";
        const normalText = "youtube.com/@chronicillnesschannel";
        ctx.font = 'bold 12px system-ui, sans-serif';
        const boldWidth = ctx.measureText(boldText).width;
        ctx.font = '12px system-ui, sans-serif';
        const normalWidth = ctx.measureText(normalText).width;
        const totalWidth = boldWidth + normalWidth;
        let channelY = footerY + 5;
        if (totalWidth > maxFooterWidth) {
          // Wrap channel text if needed
          ctx.font = 'bold 12px system-ui, sans-serif';
          const boldLines = wrapText(boldText, maxFooterWidth);
          boldLines.forEach((line, i) => {
            ctx.fillText(line, unscaledWidth / 2, channelY + i * 16);
          });
          channelY += boldLines.length * 16;
          ctx.font = '12px system-ui, sans-serif';
          const normalLines = wrapText(normalText, maxFooterWidth);
          normalLines.forEach((line, i) => {
            ctx.fillText(line, unscaledWidth / 2, channelY + i * 16);
          });
          channelY += normalLines.length * 16;
        } else {
          // Draw bold part
          ctx.font = 'bold 12px system-ui, sans-serif';
          ctx.fillText(boldText, (unscaledWidth - totalWidth) / 2 + boldWidth / 2, channelY);
          // Draw normal part
          ctx.font = '12px system-ui, sans-serif';
          ctx.fillText(normalText, (unscaledWidth - totalWidth) / 2 + boldWidth + normalWidth / 2, channelY);
          channelY += 16;
        }

        // --- Download ---
        const link = document.createElement('a');
        const safeName = pollutant.replace(/[^a-z0-9_\-]/gi, '_');
        link.download = `${safeName}_comparison.png`;
        link.href = canvas.toDataURL('image/png');
        document.body.appendChild(link);
        link.click();
        link.remove();
      };

      logo.onload = () => {
        try {
          const logoSize = 80;
          ctx.drawImage(logo, unscaledWidth - logoSize - 20, 10, logoSize, logoSize);
          finishExport();
        } catch (e) {
          console.warn('Logo failed to draw, continuing without logo:', e);
          finishExport();
        }
      };

      logo.onerror = () => {
        console.warn('Logo failed to load, continuing without logo');
        finishExport();
      };
    };

    img.onerror = (e) => {
      console.error('Failed to load chart image for export', e);
      alert('Sorry ‚Äî failed to generate the PNG from the chart image.');
    };

    img.src = imageURI;
  });
}
/* ---------------- Initialization ---------------- */
// Parse URL parameters for shared configurations
function parseUrlParameters() {
  const params = new URLSearchParams(window.location.search);
  const result = {};
  
  // Get pollutant ID
  if (params.has('pollutant_id')) {
    result.pollutant_id = params.get('pollutant_id');
  }
  
  // Get group IDs (can be comma-separated)
  if (params.has('group_ids')) {
    const groupIds = params.get('group_ids');
    result.group_ids = groupIds.split(',').map(id => id.trim()).filter(id => id);
  }
  
  // Get year range
  if (params.has('start_year')) {
    result.start_year = params.get('start_year');
  }
  
  if (params.has('end_year')) {
    result.end_year = params.get('end_year');
  }
  
  return result;
}

async function init(){
  try {
    console.log("üîÑ Initializing Supabase data...");
    
    // Track page load
    trackAnalytics('page_load', {
      version: 'v2.0 (Supabase)',
      load_time: Date.now(),
      screen_resolution: screen.width + 'x' + screen.height,
      viewport: window.innerWidth + 'x' + window.innerHeight
    });
    
    // --- Load all data once ---
    await loadUnits();
    await loadData();
    await loadGroupInfo();

    // --- Populate dropdowns ---
    setupSelectors();

    // Check if this is a shared URL that needs processing
    const urlParams = parseUrlParameters();
    const isSharedUrl = urlParams.pollutant_id || urlParams.group_ids || urlParams.start_year || urlParams.end_year;

    // For normal URLs, do all DOM setup BEFORE showing UI
    if (!isSharedUrl) {
      // Set default pollutant
      const pollutantSelect = document.getElementById("pollutantSelect");
      if (pollutantSelect.querySelector("option[value=\"PM2.5\"]")) {
        pollutantSelect.value = "PM2.5";
      }

      // Add default group selector EARLY (before any UI transitions)
      const firstGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all") || (window.allGroupsList?.[0] || "");
      if (firstGroup) {
        addGroupSelector(firstGroup, false);
      } else {
        addGroupSelector("", true); // Empty placeholder if no groups available
      }

      const revealPromise = revealMainContent();

      setupDownloadButton();
      setupSmoothingToggle();
      setupShareButton();
      setupInteractionTracking();
      document.getElementById("downloadCSVBtn").addEventListener("click", () => exportData("csv"));
      document.getElementById("downloadXLSXBtn").addEventListener("click", () => exportData("xlsx"));

      await revealPromise;
      return; // Skip URL processing for normal URLs
    }

    // --- Process shared URL parameters ---    
    const pollutantSelect = document.getElementById('pollutantSelect');
    
    // Set pollutant from URL or default to PM2.5
    if (urlParams.pollutant_id) {
      // Find pollutant name by ID
      const pollutantData = pollutantsData.find(pd => 
        pd.id === parseInt(urlParams.pollutant_id)
      );
      
      if (pollutantData) {
        const pollutantName = pollutantData.Pollutant || pollutantData.pollutant;
        if (pollutantName) {
          pollutantSelect.value = pollutantName;
          console.log(`üîó Loaded pollutant from URL: ${pollutantName} (ID: ${urlParams.pollutant_id})`);
          
          // Track shared URL usage
          trackAnalytics('shared_url_load', {
            pollutant_id: urlParams.pollutant_id,
            pollutant_name: pollutantName,
            group_ids: urlParams.group_ids || 'none',
            start_year: urlParams.start_year || '',
            end_year: urlParams.end_year || '',
            has_year_range: !!(urlParams.start_year && urlParams.end_year)
          });
        }
      }
    } else {
      // Default behavior
      const pm25 = pollutantSelect.querySelector('option[value="PM2.5"]');
      if (pm25) pollutantSelect.value = "PM2.5";
      else if (pollutantSelect.options.length > 1) pollutantSelect.selectedIndex = 1;
    }

    // Handle group selection from URL or use defaults
    const groupContainer = document.getElementById('groupContainer');
    
    if (urlParams.group_ids && urlParams.group_ids.length > 0) {
      // Load groups from URL parameters
      console.log(`üîó Loading groups from URL: ${urlParams.group_ids.join(', ')}`);
      
      // Clear any existing group selectors
      groupContainer.innerHTML = '';
      
      // Add group selectors for each ID in URL
      urlParams.group_ids.forEach(groupId => {
        const groupData = groupsData.find(gd => gd.id === parseInt(groupId));
        if (groupData) {
          const groupName = groupData.Group_Title || groupData.group_title;
          if (groupName) {
            addGroupSelector(groupName, false);
          }
        }
      });
      
      // If no valid groups were found from IDs, fall back to default
      if (groupContainer.querySelectorAll('select').length === 0) {
        console.warn('üö´ No valid groups found from URL IDs, using default');
        const defaultGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all") || (window.allGroupsList?.[0] || "");
        if (defaultGroup) addGroupSelector(defaultGroup, false);
        else addGroupSelector("", true);
      }
    } else {
      // Default behavior when no URL groups
      let firstGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all")
        || (window.allGroupsList?.[0] || "");

      // If group list is empty or doesn't contain "All", fall back to groups discovered in groupedData
      if (!firstGroup) {
        // try groups for selected pollutant first
        const chosenPoll = pollutantSelect.value || window.allPollutants?.[0];
        const groupsForPoll = chosenPoll ? Object.keys(groupedData[chosenPoll] || {}) : [];
        firstGroup = groupsForPoll[0] || (Object.values(groupedData).flatMap(p => Object.keys(p))[0] || "");
      }

      // If still no firstGroup but there's at least one group in window.allGroupsList, use that
      if (!firstGroup && window.allGroupsList && window.allGroupsList.length) {
        firstGroup = window.allGroupsList[0];
      }

      // Add a selector only if there isn't one already
      if (document.querySelectorAll('#groupContainer select').length === 0) {
        if (firstGroup) addGroupSelector(firstGroup, false);
        else addGroupSelector("", true);
      } else {
        // If selector exists but has no selection, try to set it
        const existingSel = document.querySelector('#groupContainer select');
        if (existingSel && !existingSel.value && firstGroup) existingSel.value = firstGroup;
      }
    }
    
    // --- Set year range from URL parameters ---
    const startYearSelect = document.getElementById('startYear');
    const endYearSelect = document.getElementById('endYear');
    
    if (urlParams.start_year && startYearSelect) {
      const startOption = startYearSelect.querySelector(`option[value="${urlParams.start_year}"]`);
      if (startOption) {
        startYearSelect.value = urlParams.start_year;
        console.log(`üîó Set start year from URL: ${urlParams.start_year}`);
      }
    }
    
    if (urlParams.end_year && endYearSelect) {
      const endOption = endYearSelect.querySelector(`option[value="${urlParams.end_year}"]`);
      if (endOption) {
        endYearSelect.value = urlParams.end_year;
        console.log(`üîó Set end year from URL: ${urlParams.end_year}`);
      }
    }

    // --- Chart will be drawn after UI is shown ---



    // === SHOW UI for shared URLs - after URL processing ===
    const revealPromise = revealMainContent();

    setupDownloadButton();
    setupSmoothingToggle();
    setupShareButton();
    setupInteractionTracking();
    document.getElementById("downloadCSVBtn").addEventListener("click", () => exportData("csv"));
    document.getElementById("downloadXLSXBtn").addEventListener("click", () => exportData("xlsx"));

    await revealPromise;
  } catch (err) {
    console.error("‚ùå Initialization failed:", err);
    document.getElementById('loadingOverlay').innerHTML =
      '<div style="color:#900;font-weight:700">Failed to load Supabase data ‚Äî check connection or table names.</div>';
  }

}

function setupInteractionTracking() {
  // Track "How to Use" section interactions
  const howToUseDetails = document.querySelector('details');
  if (howToUseDetails) {
    howToUseDetails.addEventListener('toggle', () => {
      if (howToUseDetails.open) {
        trackAnalytics('ui_interaction', {
          element: 'how_to_use_section',
          action: 'opened'
        });
      }
    });
  }

  // Track "Group Info" section interactions
  const groupInfoDetails = document.querySelectorAll('details')[1]; // Second details element
  if (groupInfoDetails) {
    groupInfoDetails.addEventListener('toggle', () => {
      if (groupInfoDetails.open) {
        trackAnalytics('ui_interaction', {
          element: 'group_info_section',
          action: 'opened'
        });
      }
    });
  }

  // Track smoothing toggle clicks
  const smoothBtn = document.getElementById('toggleSmoothBtn');
  if (smoothBtn) {
    smoothBtn.addEventListener('click', () => {
      trackAnalytics('ui_interaction', {
        element: 'smoothing_toggle',
        action: 'clicked',
        new_state: !smoothLines ? 'enabled' : 'disabled'
      });
    });
  }
}

function setupSmoothingToggle() {
  const btn = document.getElementById('toggleSmoothBtn');
  btn.addEventListener('click', () => {
    smoothLines = !smoothLines;
    btn.textContent = smoothLines ? 'üö´ Disable Smoothing' : '‚úÖ Enable Smoothing';
    updateChart();
  });
}
function exportData(format = 'csv') {
  const pollutant = document.getElementById('pollutantSelect').value;
  const startYear = +document.getElementById('startYear').value;
  const endYear = +document.getElementById('endYear').value;
  const selectedGroups = getSelectedGroups();
  
  console.log('Export debug:', { pollutant, startYear, endYear, selectedGroups, globalHeadersLength: window.globalHeaders?.length });
  
  if (!pollutant || !selectedGroups.length || !(window.globalHeaders?.length)) {
    console.warn('Export validation failed:', { 
      hasPollutant: !!pollutant, 
      hasGroups: selectedGroups.length > 0, 
      hasHeaders: window.globalHeaders?.length > 0 
    });
    alert('Please select a pollutant and at least one group first.');
    return;
  }

  // Track export analytics
  trackAnalytics('data_export', {
    format: format,
    pollutant: pollutant,
    start_year: startYear,
    end_year: endYear,
    groups: selectedGroups,
    groups_count: selectedGroups.length,
    year_range: endYear - startYear + 1,
    filename: pollutant.replace(/[^a-z0-9_\-]/gi, '_') + '_' + startYear + '-' + endYear + '_comparison'
  });

  // Use the global year keys / labels determined earlier
  const yearsAll = window.globalYears || [];
  const yearKeys = window.globalYearKeys || [];
  const startIdx = yearsAll.indexOf(String(startYear));
  const endIdx = yearsAll.indexOf(String(endYear));
  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    alert('Invalid year range.');
    return;
  }
  const years = yearsAll.slice(startIdx, endIdx + 1);
  const keysForYears = yearKeys.slice(startIdx, endIdx + 1);
  const unit = pollutantUnits[pollutant] || '';

  // --- Build rows ---
  const rows = [];
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 16);

  // First row: pollutant and unit
  rows.push([`Pollutant: ${pollutant}`, `Unit: ${unit}`]);
  rows.push([]); // spacer row
  // Header row
  rows.push(['Group', ...years]);


  // Data rows - read values by key for robustness
  selectedGroups.forEach(group => {
    const values = keysForYears.map((k) => {
      // look up the data row for this pollutant and group
      const dataRow = groupedData[pollutant] ? groupedData[pollutant][group] : null;
      const raw = dataRow ? dataRow[k] : null;
      return raw ?? '';
    });
    rows.push([group, ...values]);
  });


  rows.push([]); // spacer
  rows.push([`Downloaded on: ${timestamp}`]);

  // --- Generate and download file ---
  const safePollutant = pollutant.replace(/[^a-z0-9_\-]/gi, '_');
  if (format === 'csv') {
    const csvContent = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${safePollutant}_data.csv`;
    link.click();
  } else if (format === 'xlsx') {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Data');
    XLSX.writeFile(wb, `${safePollutant}_data.xlsx`);
  }
}

// Generate shareable URL with current configuration
function generateShareUrl() {
  const pollutantSelect = document.getElementById('pollutantSelect');
  const selectedGroups = getSelectedGroups();
  
  if (!pollutantSelect.value || selectedGroups.length === 0) {
    alert('Please select a pollutant and at least one group before sharing.');
    return null;
  }
  
  // Get pollutant ID
  const pollutantData = pollutantsData.find(pd => 
    (pd.Pollutant || pd.pollutant) === pollutantSelect.value
  );
  
  if (!pollutantData) {
    alert('Unable to find pollutant ID for sharing.');
    return null;
  }
  
  // Get group IDs
  const groupIds = [];
  selectedGroups.forEach(groupName => {
    const groupData = groupsData.find(gd => 
      (gd.Group_Title || gd.group_title) === groupName
    );
    if (groupData) {
      groupIds.push(groupData.id);
    }
  });
  
  if (groupIds.length === 0) {
    alert('Unable to find group IDs for sharing.');
    return null;
  }
  
  // Get year selections
  const startYearSelect = document.getElementById('startYear');
  const endYearSelect = document.getElementById('endYear');
  const startYear = startYearSelect ? startYearSelect.value : null;
  const endYear = endYearSelect ? endYearSelect.value : null;
  
  // Build URL with all parameters
  const baseUrl = window.location.origin + window.location.pathname;
  let shareUrl = `${baseUrl}?pollutant_id=${pollutantData.id}&group_ids=${groupIds.join(',')}`;
  
  // Add year parameters if they are set
  if (startYear) {
    shareUrl += `&start_year=${startYear}`;
  }
  if (endYear) {
    shareUrl += `&end_year=${endYear}`;
  }
  
  return shareUrl;
}

// Setup share button functionality
function setupShareButton() {
  const shareBtn = document.getElementById('shareBtn');
  if (!shareBtn) return;
  
  shareBtn.addEventListener('click', () => {
    const shareUrl = generateShareUrl();
    if (!shareUrl) return;
    
    // Track share usage
    trackAnalytics('share_button_click', {
      pollutant: document.getElementById('pollutantSelect').value,
      group_count: getSelectedGroups().length,
      start_year: document.getElementById('startYear')?.value || '',
      end_year: document.getElementById('endYear')?.value || '',
      year_span: (document.getElementById('endYear')?.value && document.getElementById('startYear')?.value) 
        ? (parseInt(document.getElementById('endYear').value) - parseInt(document.getElementById('startYear').value) + 1) 
        : null
    });
    
    // Show share options
    showShareDialog(shareUrl);
  });
}

// Show share dialog with copy and email options
function showShareDialog(shareUrl) {
  const pollutantName = document.getElementById('pollutantSelect').value;
  const selectedGroups = getSelectedGroups();
  const startYear = document.getElementById('startYear')?.value || '';
  const endYear = document.getElementById('endYear')?.value || '';
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    background: white;
    padding: 24px;
    border-radius: 12px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  `;
  
  const yearRange = (startYear && endYear) ? ` (${startYear}-${endYear})` : '';
  const title = `${pollutantName} - ${selectedGroups.join(', ')}${yearRange}`;
  const description = `View ${pollutantName} emissions data for ${selectedGroups.length === 1 ? selectedGroups[0] : selectedGroups.length + ' groups'}${yearRange ? ` from ${startYear} to ${endYear}` : ''} using the NAEI Multi-Group Pollutant Viewer.`;
  
  content.innerHTML = `
    <h3 style="margin: 0 0 16px 0; color: #333;">üîó Share Chart</h3>
    <p style="margin: 0 0 16px 0; color: #666;">Share this specific chart configuration:</p>
    <p style="margin: 0 0 16px 0; font-weight: 600; color: #000;">${title}</p>
    
    <div style="margin: 16px 0;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Shareable URL:</label>
      <div style="display: flex; gap: 8px;">
   <input type="text" id="shareUrlInput" name="shareUrlInput" value="${shareUrl}" readonly 
     style="flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; background: #f9f9f9;">
        <button id="copyUrlBtn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
          üìã Copy
        </button>
      </div>
    </div>
    
    <div style="margin: 16px 0;">
      <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
  <input type="checkbox" id="includeImageCheckbox" name="includeImageCheckbox" style="margin-right: 8px;">
        <span style="font-weight: 600;">üñºÔ∏è Copy chart image to clipboard for pasting into email</span>
      </label>
      
      <button id="emailShareBtn" style="padding: 12px 20px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-right: 8px;">
        üìß Email Link
      </button>
      <button id="closeShareBtn" style="padding: 12px 20px; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
        ‚ùå Close
      </button>
    </div>
  `;
  
  dialog.appendChild(content);
  document.body.appendChild(dialog);
  
  // Copy URL functionality
  content.querySelector('#copyUrlBtn').addEventListener('click', async () => {
    const input = content.querySelector('#shareUrlInput');
    try {
      await navigator.clipboard.writeText(shareUrl);
      const btn = content.querySelector('#copyUrlBtn');
      btn.textContent = '‚úÖ Copied!';
      btn.style.background = '#4CAF50';
      
      trackAnalytics('share_url_copied', {
        pollutant: pollutantName,
        group_count: selectedGroups.length,
        start_year: startYear,
        end_year: endYear,
        has_year_range: !!(startYear && endYear)
      });
      
      setTimeout(() => {
        btn.textContent = 'üìã Copy';
        btn.style.background = '#4CAF50';
      }, 2000);
    } catch (err) {
      // Fallback for older browsers
      input.select();
      document.execCommand('copy');
      alert('URL copied to clipboard!');
    }
  });
  
  // Email sharing functionality
  content.querySelector('#emailShareBtn').addEventListener('click', async () => {
    const includeImage = content.querySelector('#includeImageCheckbox').checked;
    
    // Create detailed email content
    const subject = encodeURIComponent(`NAEI Emissions Data: ${pollutantName} ${yearRange}`);
    
    let emailBody = `I'm sharing NAEI emissions data for ${pollutantName}${yearRange ? ` from ${startYear} to ${endYear}` : ''}.\n\n`;
    emailBody += `Groups included:\n`;
    selectedGroups.forEach((group, index) => {
      emailBody += `${index + 1}. ${group}\n`;
    });
    emailBody += `\n`;
    
    if (includeImage) {
      try {
        // Generate comprehensive chart image (same as PNG download)
        const chartImageData = await generateChartImage();
        
        // Copy to clipboard
        if (navigator.clipboard && navigator.clipboard.write && typeof ClipboardItem !== 'undefined') {
          const blob = dataURLtoBlob(chartImageData);
          const clipboardItem = new ClipboardItem({ 'image/png': blob });
          await navigator.clipboard.write([clipboardItem]);
          
          emailBody += `üñºÔ∏è Chart Image:\n`;
          emailBody += `The complete chart image (including title, legend, and CIC logo) has been copied to your clipboard.\n`;
          emailBody += `You can now paste it directly into your email.\n\n`;
        } else {
          emailBody += `üìã Chart Image:\n`;
          emailBody += `Your browser doesn't support automatic clipboard copying.\n`;
          emailBody += `Please use the "‚¨áÔ∏è Download Chart as PNG" button to get the chart image.\n\n`;
        }
        
      } catch (error) {
        console.warn('Could not generate chart image:', error);
        emailBody += `üñºÔ∏è Chart Image:\n`;
        emailBody += `Chart image could not be generated automatically.\n`;
        emailBody += `Please use the "‚¨áÔ∏è Download Chart as PNG" button to get the chart image.\n\n`;
      }
    }
    
    emailBody += `Interactive chart: ${shareUrl}\n\n`;
    emailBody += `Generated by the Chronic Illness Channel NAEI Multi-Group Pollutant Viewer\n`;
    emailBody += `Youtube Channel: http://youtube.com/@chronicillnesschannel`;
    
    const body = encodeURIComponent(emailBody);
    const mailto = `mailto:?subject=${subject}&body=${body}`;
    
    trackAnalytics('share_email_opened', {
      pollutant: pollutantName,
      group_count: selectedGroups.length,
      start_year: startYear,
      end_year: endYear,
      has_year_range: !!(startYear && endYear),
      include_image: includeImage
    });
    
    window.location.href = mailto;
  });
  
  // Close dialog
  const closeDialog = () => {
    document.body.removeChild(dialog);
  };
  
  content.querySelector('#closeShareBtn').addEventListener('click', closeDialog);
  dialog.addEventListener('click', (e) => {
    if (e.target === dialog) closeDialog();
  });
  
  // Focus the URL input for easy copying
  setTimeout(() => {
    content.querySelector('#shareUrlInput').select();
  }, 100);
}

// Generate comprehensive chart image for email sharing (same as PNG download)
async function generateChartImage() {
  return new Promise((resolve, reject) => {
    try {
      const pollutant = document.getElementById('pollutantSelect').value;
      if (!chart || !pollutant) {
        reject(new Error('Chart or pollutant not available'));
        return;
      }

      const unit = pollutantUnits[pollutant] || "";
      const imageURI = chart.getImageURI();
      const img = new Image();
      img.crossOrigin = 'anonymous';

      img.onload = () => {
        try {
          // --- Measure legend for layout ---
          const legendClone = document.getElementById('customLegend').cloneNode(true);
          legendClone.style.position = 'absolute';
          legendClone.style.visibility = 'hidden';
          legendClone.style.width = Math.min(800, img.width) + 'px';
          document.body.appendChild(legendClone);
          const legendHeight = legendClone.offsetHeight + 10;
          document.body.removeChild(legendClone);

          const titleHeight = 30;
          const footerHeight = 40;
          const padding = 20;

          // --- Determine output size ---
          const unscaledWidth = img.width + padding * 2;
          const unscaledHeight = img.height + titleHeight + legendHeight + footerHeight + padding * 3;

          // --- Create canvas ---
          const canvas = document.createElement('canvas');
          canvas.width = unscaledWidth;
          canvas.height = unscaledHeight;
          const ctx = canvas.getContext('2d');

          // --- Background ---
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, unscaledWidth, unscaledHeight);

          // --- Title ---
          ctx.font = 'bold 18px system-ui, sans-serif';
          ctx.fillStyle = '#000000';
          ctx.textAlign = 'center';
          ctx.fillText(
            `${pollutant}${unit ? " (" + unit + ")" : ""}`,
            unscaledWidth / 2,
            padding + 15
          );

          // --- Legend ---
          const legendDiv = document.getElementById('customLegend');
          const items = [...legendDiv.querySelectorAll('span')];
          let legendY = padding + 35;
          const legendRowHeight = 22;
          const maxW = unscaledWidth - padding * 2;
          const rowItems = [];
          let row = [], rowW = 0;

          items.forEach((it) => {
            const dot = it.querySelector('span');
            if (!dot) return;
            const text = it.textContent.trim();
            ctx.font = '600 14px system-ui, sans-serif';
            const textW = ctx.measureText(text).width;
            const w = textW + 40;
            if (rowW + w > maxW && row.length) {
              rowItems.push({ row, rowW });
              row = [];
              rowW = 0;
            }
            row.push({ dotColor: dot.style.backgroundColor, text });
            rowW += w;
          });

          if (row.length) rowItems.push({ row, rowW });

          rowItems.forEach(({ row, rowW }) => {
            let x = (unscaledWidth - rowW) / 2;
            row.forEach(({ dotColor, text }) => {
              const faded = text.includes('(No data available)');
              ctx.globalAlpha = faded ? 0.4 : 1.0;
              ctx.beginPath();
              ctx.arc(x + 6, legendY - 5, 6, 0, 2 * Math.PI);
              ctx.fillStyle = dotColor;
              ctx.fill();
              ctx.font = '600 14px system-ui, sans-serif';
              ctx.fillStyle = '#000000';
              ctx.textAlign = 'left';
              ctx.fillText(text, x + 18, legendY);
              ctx.globalAlpha = 1.0;
              x += ctx.measureText(text).width + 40;
            });
            legendY += legendRowHeight;
          });

          // --- Chart image ---
          ctx.drawImage(img, padding, legendY + 10);

          // --- Logo and footer ---
          const logo = new Image();
          logo.crossOrigin = 'anonymous';
          logo.src = 'CIC - Square - Border - Words - Alpha 360x360.png';

          const finishGeneration = () => {
            const footerText = "¬© Crown 2025 copyright Defra & DESNZ via naei.energysecurity.gov.uk licensed under the Open Government Licence (OGL).";
            const channelText = "Youtube Channel: youtube.com/@chronicillnesschannel";
            
            ctx.font = '12px system-ui, sans-serif';
            ctx.fillStyle = '#555';
            ctx.textAlign = 'center';
            ctx.fillText(footerText, unscaledWidth / 2, legendY + img.height + 20);
            
            // Draw YouTube channel with bold label
            const channelY = legendY + img.height + 35;
            const boldText = "Youtube Channel: ";
            const normalText = "youtube.com/@chronicillnesschannel";
            
            // Measure text widths for positioning
            ctx.font = 'bold 12px system-ui, sans-serif';
            const boldWidth = ctx.measureText(boldText).width;
            ctx.font = '12px system-ui, sans-serif';
            const normalWidth = ctx.measureText(normalText).width;
            const totalWidth = boldWidth + normalWidth;
            
            // Draw bold part
            ctx.font = 'bold 12px system-ui, sans-serif';
            ctx.fillText(boldText, (unscaledWidth - totalWidth) / 2 + boldWidth / 2, channelY);
            
            // Draw normal part
            ctx.font = '12px system-ui, sans-serif';
            ctx.fillText(normalText, (unscaledWidth - totalWidth) / 2 + boldWidth + normalWidth / 2, channelY);
            
            const dataURL = canvas.toDataURL('image/png');
            resolve(dataURL);
          };

          logo.onload = () => {
            try {
              const logoSize = 80;
              ctx.drawImage(logo, unscaledWidth - logoSize - 20, 10, logoSize, logoSize);
              finishGeneration();
            } catch (e) {
              console.warn('Logo failed to draw, continuing without logo:', e);
              finishGeneration();
            }
          };

          logo.onerror = () => {
            console.warn('Logo failed to load, continuing without logo');
            finishGeneration();
          };

        } catch (error) {
          reject(error);
        }
      };

      img.onerror = (e) => {
        reject(new Error('Failed to load chart image for generation'));
      };

      img.src = imageURI;
    } catch (error) {
      reject(error);
    }
  });
}

// Convert data URL to Blob for clipboard
function dataURLtoBlob(dataURL) {
  const arr = dataURL.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}

async function loadGroupInfo() {
  try {
    let groupRows = [];
    let nfrRows = [];

    if (supabase) {
      const { data: supabaseGroups, error: groupError } = await supabase
        .from('NAEI_global_t_Group')
        .select('id,Group_Title,SourceName,ActivityName,NFRCode');

      if (groupError) {
        console.warn('Failed to load group info from Supabase:', groupError);
      } else {
        groupRows = supabaseGroups || [];
      }

      try {
        const { data: supabaseNfr, error: nfrError } = await supabase
          .from('NAEI_global_t_NFRCode')
          .select('*');

        if (nfrError) {
          console.warn('Failed to load NFR code descriptions from Supabase:', nfrError);
        } else {
          nfrRows = supabaseNfr || [];
        }
      } catch (nfrErr) {
        console.warn('Failed to load NFR code descriptions from Supabase:', nfrErr);
      }
    } else {
      console.warn('Supabase client unavailable; falling back to cached group rows.');
    }

    if (!groupRows.length && groupsData && groupsData.length) {
      groupRows = groupsData;
    }

    if (!groupRows.length) {
      throw new Error('No group information available from Supabase or cached data.');
    }

    const nfrMap = {};
    nfrRows.forEach(nfr => {
      const code = nfr?.NFRCode || nfr?.nfrcode || nfr?.nfr_code;
      const description = nfr?.Description || nfr?.description;
      if (code && description) {
        nfrMap[code] = description;
      }
    });

    const groupMap = {};

    groupRows.forEach(row => {
      const groupTitle = row?.Group_Title || row?.group_title || row?.Group || row?.group;
      const sourceName = row?.SourceName || row?.source_name || row?.Source || row?.source;
      const activityName = row?.ActivityName || row?.activity_name || row?.Activity || row?.activity;
      const nfrCodeField = row?.NFRCode || row?.nfrcode || row?.nfr_code;

      if (!groupTitle) return;

      if (!groupMap[groupTitle]) {
        groupMap[groupTitle] = {
          name: groupTitle,
          sources: new Set(),
          activities: new Set(),
          nfrCodes: new Set()
        };
      }

      if (sourceName) {
        groupMap[groupTitle].sources.add(sourceName);
      }

      if (activityName) {
        groupMap[groupTitle].activities.add(activityName);
      }

      if (nfrCodeField) {
        nfrCodeField
          .split(/[;,]/)
          .map(code => code.trim())
          .filter(Boolean)
          .forEach(code => groupMap[groupTitle].nfrCodes.add(code));
      }
    });

    const groups = Object.values(groupMap)
      .map(g => ({
        name: g.name,
        sources: Array.from(g.sources).sort(),
        activities: Array.from(g.activities).sort(),
        nfrCodes: Array.from(g.nfrCodes).sort()
      }))
      .sort((a, b) => {
        if (a.name.toLowerCase() === 'all') return -1;
        if (b.name.toLowerCase() === 'all') return 1;
        return a.name.localeCompare(b.name);
      });

    if (!groups.length) {
      throw new Error('Group information could not be aggregated.');
    }

    let html = `
      <table id="groupTable" style="border-collapse:collapse;width:100%;font-family:inherit;font-size:14px;color:#000;">
        <thead>
          <tr style="background:#d0d0d0;">
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:25%;">Group Name</th>
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:40%;">Sources</th>
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:35%;">Fuel Types (Activity in NAEI data)</th>
          </tr>
        </thead>
        <tbody>
    `;

    groups.forEach(g => {
        let sourcesHTML = '';
        // Filter NFR codes to only valid ones
        const validNfrCodes = g.nfrCodes.filter(code => code && code !== 'NULL' && code !== '' && code !== null);
        if (validNfrCodes.length) {
          sourcesHTML += `<span style="text-decoration:underline;font-weight:600;display:block;margin-bottom:4px;">All Sources from the following NFR Code categories:</span>`;
          sourcesHTML += `<div style="white-space:pre-line;">`;
          validNfrCodes.forEach(code => {
            const description = nfrMap[code];
            if (description && description !== 'NULL') {
              sourcesHTML += `${code}: ${description}\n`;
            } else {
              sourcesHTML += `${code}\n`;
            }
          });
          sourcesHTML += `</div>`;
        } else {
          const validSources = g.sources.filter(s => s != null && s !== '' && s !== 'NULL');
          sourcesHTML = validSources.length ? validSources.join('\n') : 'All Sources';
        }

      const activitiesText = g.activities.length ? g.activities.join('\n') : 'All Fuel Types';

      html += `
        <tr style="border:1px solid #444;">
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${g.name}</td>
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${sourcesHTML}</td>
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${activitiesText}</td>
        </tr>
      `;
    });

    html += '</tbody></table>';

    const container = document.getElementById('group-info');
    container.style.fontFamily = 'system-ui, sans-serif';
    container.style.fontSize = '14px';
    container.style.color = '#000';
    container.innerHTML = html;

    console.log(`Rendered group info for ${groups.length} groups (Supabase rows: ${groupRows.length}).`);
  } catch (err) {
    console.error('Error loading group info:', err);
    document.getElementById('group-info').innerHTML =
      "<p class='text-red-600'>‚ö†Ô∏è Could not load group or NFRCodes information.</p>";
  }
}
document.addEventListener('DOMContentLoaded', () => google.charts.setOnLoadCallback(init));
</script>
</body>
</html>
</html>