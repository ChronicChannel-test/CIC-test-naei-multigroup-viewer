
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NAEI Multi-Group Pollutant Viewer</title>
  <link rel="icon" type="image/png" sizes="64x64" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">

  <!-- Social preview / link preview meta tags -->
  <meta name="description" content="NAEI Multi-Group Pollutant Viewer">
  <!-- Open Graph (Facebook, LinkedIn, Slack, etc.) -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="NAEI Multi-Group Pollutant Viewer">
  <meta property="og:description" content="Compare emissions from grouped NAEI sources across years. Interactive charts, CSV/XLSX export and downloadable images.">
  <meta property="og:url" content="https://github.com/Chronic-Illness-Channel/naei-multigroup-viewer">
  <meta property="og:image" content="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">
  <meta property="og:image:width" content="1120">
  <meta property="og:image:height" content="630">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="NAEI Multi-Group Pollutant Viewer">
  <meta name="twitter:description" content="Compare emissions from grouped NAEI sources across years.">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">
  <meta name="twitter:site" content="@Chronic_Channel">
  <meta name="twitter:creator" content="@Chronic_Channel">
  <!-- Legacy image hint -->
  <link rel="image_src" href="https://raw.githubusercontent.com/Chronic-Illness-Channel/naei-multigroup-viewer/4edd238fc210f2019c4d6b9101bee18172148270/CIC%20-%20NAEI%20Multi-Group%20Viewer%20Thumbnail.1120x630.png">

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  
  <script src="https://www.gstatic.com/charts/loader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; color: #000; background:#fff; }
    label { font-weight:600; margin-right:6px; }
    .title-row {
      position: relative;
      margin-bottom: 0;
    }
  #cicLogo {
    width: 110px;
    height: auto;
    display: block;
  }
  .sidebar-socials {
    position: absolute;
    top: 0;
    right: 0;
    width: 110px;
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 100;
  }
  .sidebar-icons {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    align-items: flex-end;
  }
  .sidebar-link {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 40px;
    height: 40px;
  }
  .sidebar-link img {
    display: block;
    height: 40px;
    width: 40px;
    object-fit: contain;
  }
  a[href*="facebook.com"] img {
    width: 36px;
    height: 36px;
  }
	
    h2 { margin-bottom:8px; width: 100%; display: block; }

    /* Main title styling - keep desktop behaviour similar to V1 */
    .main-title {
      margin: 0 0 20px 0;
      padding-right: 140px;
      font-size: 26px;
      font-weight: 700;
      line-height: 1.3;
      white-space: normal;
      overflow-wrap: normal;
      text-align: left;
    }

    .main-title .title-part {
      display: inline;
      white-space: nowrap;
    }
    
    /* Mobile styles */
    @media (max-width: 768px) {
      body {
        margin: 15px;
      }
    }

    @media (max-width: 480px) {
      body {
        margin: 15px;
      }
    }

    @media (max-width: 760px) {
      .main-title {
        padding-right: 0;
      }

      .main-title .title-part-2 {
        display: block;
      }
    }
	
  select, button { margin:4px; padding:6px 10px; border-radius:6px; border:1px solid #ccc; }
    
    /* Ensure buttons match v1 styling exactly - force override */
    #downloadBtn, #toggleSmoothBtn, #downloadCSVBtn, #downloadXLSXBtn, #shareBtn, .add-btn, .remove-btn {
      background: #EFEFEF !important;
      cursor: pointer !important;
      margin: 6px !important;
      padding: 6px 10px !important;
      border-radius: 6px !important;
      border: 1px solid #ccc !important;
      font-family: system-ui, sans-serif !important;
      color: inherit !important;
    }
    
    #downloadBtn:hover, #toggleSmoothBtn:hover, #downloadCSVBtn:hover, #downloadXLSXBtn:hover, #shareBtn:hover, .add-btn:hover, .remove-btn:hover {
      background: #E0E0E0 !important;
    }
    
    /* Ensure select dropdowns match v1 styling exactly */
    select, #pollutantSelect, #startYear, #endYear, #groupContainer select {
      margin: 6px !important;
      padding: 6px 10px !important;
      border-radius: 6px !important;
      border: 1px solid #ccc !important;
      background: #fff !important;
      font-family: system-ui, sans-serif !important;
      color: inherit !important;
    }
    
    #groupContainer { margin-top:10px; }
  .groupRow { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .groupRow.dragging { opacity:0.5; }
    .dragHandle { cursor:grab; user-select:none; padding:4px 6px; background:#f0f0f0; border-radius:6px; }
  /* Keep select and remove button together */
  .group-control { display: inline-flex; align-items: center; gap: 8px; }
    #chartTitle { font-weight:700; font-size:18px; margin-top:8px; margin-bottom:6px; text-align:center; }
  .chart-wrapper {
    width: calc(100% - 140px);
    padding: 8px;
    margin: 0;
    margin-right: auto;
    border: 1px solid #ccc;
    border-radius: 6px;
    box-sizing: border-box;
    background-color: #fff;
    overflow: hidden;
  }
  #chart_div { 
    width: 100%; 
    height: 60vh; 
    margin-top: 0; 
    opacity: 0; 
    transition: opacity .35s ease; 
    min-height: 40vh; 
    border: none;
    border-radius: 0; 
    padding: 0; 
    box-sizing: border-box;
  }
    #chart_div.visible { opacity:1; }
    button { background:#EFEFEF; cursor:pointer; }
    button:hover { background:#E0E0E0; }
    button:disabled { background:#EEE; color:#666; cursor:not-allowed; }
    .add-btn, .remove-btn { display:inline-flex; align-items:center; gap:6px; }
    .remove-icon { display:inline-block; width:18px; height:18px; border-radius:50%; background:#d33; color:#fff; text-align:center; line-height:18px; font-weight:bold; }
    .add-btn .add-icon { color:#4CAF50; font-weight:bold; font-size:2em; }
    .add-btn:hover .add-icon { color:#45a049; }
    #loadingOverlay { position:fixed; top:0; left:0; width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; background:rgba(255,255,255,0.98); z-index:9999; transition:opacity .35s ease; }
    .spinner { width:72px; height:72px; border-radius:50%; background: conic-gradient(#E6194B 0deg 120deg,#F58231 120deg 240deg,#FFE119 240deg 360deg); animation:spin 1.25s linear infinite; box-shadow:0 0 12px rgba(0,0,0,0.08); }
    @keyframes spin { from { transform:rotate(0deg); } to { transform:rotate(360deg); } }
    .loading-text { margin-top:12px; color:#333; font-weight:600; }
  #mainContent { display:none; opacity:0; transition:opacity .4s ease; }
  #mainContentTop { padding-right: 0; }
  #mainContentBottom { padding-right: 0; }
    #mainContent.loaded { opacity:1; }
    /* Fix cursor for clickable summary elements */
    details summary { cursor: pointer; user-select: none; }
    details summary::-webkit-details-marker { cursor: pointer; }
    /* Prevent text cursor only on non-text UI elements */
    .chart-container, #chart_div { cursor: default; user-select: none; }
    /* Ensure interactive elements have pointer cursor */
    button, .add-btn, .remove-btn, .dragHandle { cursor: pointer; user-select: none; }
  .button-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: flex-start;
  align-items: center;
  margin-bottom: 12px;
  padding-right: 130px;
  }
  .year-download-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  padding-right: 130px;
  }
  @media (max-width: 620px) {
    .title-row {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .sidebar-socials {
      position: static;
      width: 100%;
      flex-direction: row;
      align-items: flex-start;
      margin-bottom: 16px;
      gap: 12px;
    }
    #cicLogo {
      width: 90px;
    }
    .sidebar-icons {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 8px;
      margin-top: 0;
      width: auto;
    }
    .sidebar-link {
      width: 35px;
      height: 35px;
      margin-bottom: 0;
    }
    .sidebar-link img {
      width: 35px;
      height: 35px;
    }
    a[href*="facebook.com"] img {
      width: 32px;
      height: 32px;
    }
    .main-title {
      padding-right: 0;
      width: 100%;
    }
    .chart-wrapper {
      width: 100%;
      max-width: 100%;
    }
  }
  @media (max-width:760px){
  #mainContentTop {
    padding-right: 0 !important;
  }
    .button-row {
  width: 100% !important;
  margin-right: 0 !important;
    }
  }
  
    /* Use pointer cursor for interactive form elements */
    input, textarea, select { cursor: pointer; }

  /* Year/download row spacing tweaks */
  .year-download-row label { white-space: nowrap; margin-right: 4px; }
  .year-download-row select { margin-left: 0; margin-right: 8px; }
  .year-download-row button { margin-left: 4px; margin-right: 4px; }
  .year-pair { display: inline-flex; align-items: center; white-space: nowrap; margin-right: 8px; }

    /* Reduce vertical spacing for compact layout */
    .button-row, .year-download-row, #groupContainer, .groupRow { row-gap: 6px; }

    /* Mobile: stack group controls and move remove button below */
    @media (max-width: 760px) {
      .groupRow { flex-direction: column; align-items: flex-start; gap:6px; }
      .groupRow .remove-btn { align-self: flex-start; margin-top: 4px; }
      .year-download-row { max-width: 100%; margin-right: 0; }
    }
	/* --- Legend dot alignment fix --- */
	#customLegend {
	  margin-top: 10px;
	  display: flex;
	  flex-wrap: wrap;
	  justify-content: center;
	  align-items: center;
	  font-family: system-ui, sans-serif;
	  gap: 10px; /* space between legend items */
	}

	#customLegend span {
	  display: inline-flex;
	  align-items: center;     /* centers dot + text vertically */
	  gap: 4px;                /* tighter gap between dot and text */
	  margin: 4px 8px;         /* small spacing between items */
	  cursor: pointer;
	  font-weight: 600;
	  line-height: 1;
	  user-select: none;
	}

	#customLegend span > span {
	  width: 10px;             /* smaller dot */
	  height: 10px;
	  border-radius: 50%;
	  flex-shrink: 0;
	  transform: translateY(1px); /* tiny vertical optical fix */
	}
	
	/* --- Footer centering fix --- */
	footer {
	  width: 100%;
	  text-align: center;
	  font-size: 12px;
	  color: #555;
	  margin-top: 8px;
	  line-height: 1.4;
	  font-family: system-ui, sans-serif;
	}

	footer a {
	  color: #3366cc;
	  text-decoration: none;
	}

	footer a:hover {
	  text-decoration: underline;
	}

  summary {
    width: fit-content;
  }

  .kofi-button {
    display: flex;
    flex-direction: row-reverse;
    align-items: center;
    background-color: #ff9301;
    border-radius: 8px;
    height: 40px;
    width: 40px;
    color: white;
    text-decoration: none;
    overflow: hidden;
    transition: width 0.3s ease-in-out;
    margin-top: 8px;
  }

  .kofi-button:hover {
    width: 250px;
  }

  .kofi-button .kofi-icon {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    padding: 4px;
    box-sizing: border-box;
  }

  .kofi-button .kofi-text {
    white-space: nowrap;
    padding-left: 15px;
    font-weight: bold;
  }
  
  </style>
</head>

<body>
  <div id="loadingOverlay">
    <div class="spinner" aria-hidden="true"></div>
    <div class="loading-text">Loading data, please wait‚Ä¶</div>
  </div>

  <div id="mainContent" aria-hidden="true">
    <div id="mainContentTop">
      <div class="title-row">
        <div class="sidebar-socials">
          <a href="https://www.youtube.com/@ChronicIllnessChannel" target="_blank" rel="noopener" style="cursor:pointer;">
            <img id="cicLogo" src="CIC - Square - Border - Words - Alpha 360x360.png" alt="CIC Logo">
          </a>
          <div class="sidebar-icons">
            <a href="https://youtube.com/@ChronicIllnessChannel" class="sidebar-link" target="_blank" rel="noopener">
              <img src="youtube-logo-6.svg" alt="YouTube">
            </a>
            <a href="https://bsky.app/profile/chronicchannel.bsky.social" class="sidebar-link" target="_blank" rel="noopener">
              <img src="Bluesky_Logo.svg" alt="Bluesky">
            </a>
            <a href="https://twitter.com/@Chronic_Channel" class="sidebar-link" target="_blank" rel="noopener">
              <img src="Twitter dead bird with X.svg" alt="Twitter/X">
            </a>
            <a href="https://facebook.com/ChronicIllnessChannel" class="sidebar-link" target="_blank" rel="noopener">
              <img src="facebook.svg" alt="Facebook">
            </a>
            <a href="https://ko-fi.com/F2F21NGXA3" class="kofi-button" target="_blank" rel="noopener">
              <span class="kofi-text">Support Chronic Illness Channel</span>
              <img class="kofi-icon" src="kofi_symbol.svg" alt="Ko-fi">
            </a>
          </div>
        </div>
        <h2 class="main-title"><span class="title-part title-part-1">NAEI Multi-Group</span> <span class="title-part title-part-2">Pollutant Viewer</span></h2>
      </div>
      <!-- Everything above the chart (dropdowns, buttons, group info, etc.) -->
    </div>
  <details class="my-4 bg-gray-50 border border-gray-300 rounded-2xl p-4 shadow-sm">
  <summary class="cursor-pointer text-lg font-semibold text-blue-700 hover:text-blue-900">
    üìò Quick Start Guide
  </summary>

  <div class="mt-3 space-y-3 text-gray-800 leading-relaxed">
    <p>
      <strong>Quick Start Guide:</strong> Select a <strong>pollutant</strong>, choose one or more <strong>groups</strong> to compare, set your <strong>year range</strong>, and view the interactive chart.
    </p>

 
    <h3 class="font-semibold text-blue-700">Essential Steps</h3>
    <p>
    <ol class="list-decimal list-inside space-y-2">
      <li><strong>Select Pollutant:</strong> Choose from PM2.5, NOx, CO‚ÇÇ, etc.</li>
      <li><strong>Add Groups:</strong> Compare emission sources like "Road Transport" vs "Power Stations"</li>
      <li><strong>Set Years:</strong> Focus on specific time periods (1970-2023 available)</li>
      <li><strong>Interact:</strong> Hover over chart points, click legend items to show/hide lines</li>
      <li><strong>Export & Share:</strong> Download images, export data, or share via URL</li>
    </ol>
<!-- 
    <div style="text-align: center; margin: 25px 0;">
      <a href="../help.html" 
         style="display: inline-block; background: #2196F3; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; font-weight: 600; box-shadow: 0 2px 8px rgba(33,150,243,0.3);">
        üìñ View Complete User Guide
      </a>
    </div>

    <p style="font-size: 14px; color: #666; text-align: center;">
      Complete documentation covers sharing, exporting, group details, troubleshooting, and all advanced features.
 -->
  </div>
    <p>
      Click <strong>‚Äú+ Add Group‚Äù</strong> to add a new group comparison (e.g., Road Transport, Power Stations, Domestic Combustion).<br>
      You can add up to <strong>10 groups</strong> to compare at once.<br>
  To remove a group, click <strong>‚Äú‚àí Remove Group‚Äù</strong> next to it (this appears when two or more groups are selected).
    </p>
    <p class="italic text-sm text-gray-600">
      üí° Tip: You can re-order the group boxes by clicking and dragging the ‚†ø handle next to each group ‚Äî the chart updates automatically.
    </p>

    <h3 class="font-semibold text-blue-700">3Ô∏è‚É£ Set the Year Range</h3>
    <p>
      Use the <strong>Start Year</strong> and <strong>End Year</strong> dropdowns to focus on a particular time period.<br>
      The chart will automatically refresh to show data for the chosen range.
    </p>

    <h3 class="font-semibold text-blue-700">4Ô∏è‚É£ View and Interact with the Chart</h3>
    <p>
      Once you‚Äôve chosen your pollutant, groups, and years, the interactive line chart will appear.<br>
      <strong>Hover</strong> over any point on the chart to see the exact emission value for that year.<br>
      The <strong>Y-axis</strong> shows total emissions, including units (e.g., kilotonnes).<br>
      Each group is shown in a unique colour.
    </p>

    <h3 class="font-semibold text-blue-700">5Ô∏è‚É£ Use the Legend to Toggle Lines</h3>
    <p>
      Above the chart, the legend lists all groups and their corresponding colours.<br>
      <strong>Click a group name</strong> in the legend to hide or show that group‚Äôs line on the chart.<br>
      Faded items indicate hidden or unavailable data.<br>
      <em>(Groups labelled ‚Äú(No data available)‚Äù are included for reference but contain no plotted values.)</em>
    </p>

    <h3 class="font-semibold text-blue-700">6Ô∏è‚É£ Smooth or Straight Lines</h3>
    <p>
      Click the <strong>‚Äúüö´ Disable Smoothing‚Äù</strong> button to switch to straight (non-curved) lines.<br>
      Click again (the button will change to <strong>‚Äú‚úÖ Enable Smoothing‚Äù</strong>) to re-enable smooth, curved lines.
    </p>

<h3 class="font-semibold text-blue-700">7Ô∏è‚É£ Download Options</h3>
<p>You can export both the chart and its underlying data for your own analysis or reporting.</p>

<p>
  <strong>üìä Download Chart as PNG</strong><br>
  Click <strong>‚Äú‚¨áÔ∏è Download Chart as PNG‚Äù</strong> to save the current chart as an image.<br>
  The exported image includes:
  <ul class="list-disc list-inside ml-4">
    <li>The chart itself</li>
    <li>Custom colour legend</li>
    <li>Pollutant name and emission unit</li>

  </ul>
</p>

<p>
  <strong>üìÑ Download Data</strong><br>
  <strong>CSV:</strong> Click ‚ÄúüìÑ Download Data ‚Äì CSV‚Äù for a spreadsheet-friendly text file.<br>
  <strong>Excel:</strong> Click ‚Äúüìä Download Data ‚Äì Excel‚Äù for a formatted Excel workbook.<br>
  Each file includes:
  <ul class="list-disc list-inside ml-4">
    <li>Pollutant name and emission unit in the first line</li>
    <li>Table with groups as rows and years as columns</li>
    <li>Footer row with download timestamp</li>
  </ul>
</p>

<h3 class="font-semibold text-blue-700">8Ô∏è‚É£ Share Your Chart</h3>
<p>
  Click the <strong>Share</strong> button to copy a unique link or chart image.<br>
  You can easily share your current view with others, or paste the chart image into emails and documents.<br>
  The shared link will open the viewer with your selected pollutant, groups, and year range.
</p>

<h3 class="font-semibold text-blue-700">9Ô∏è‚É£ View Group Details</h3>
<p>
  Use the <strong>‚Äúüìò See Group Info‚Äù</strong> section below the group selector to view details of how each group is built.<br>
  The table shows <strong>Source Names</strong> and <strong>Fuel Types</strong> from the NAEI data that have been combined to create each group.<br>
  If a group includes all sources or all fuel types, these will be shown as <em>‚ÄúAll Sources‚Äù</em> or <em>‚ÄúAll Fuel Types‚Äù</em>.
</p>

<h3 class="font-semibold text-blue-700">üîü Licensing and Attribution</h3>
<p>
  ¬© Crown copyright (Defra & DESNZ) and available under the
  <strong>Open Government Licence (OGL)</strong>.<br>
  See links beneath the chart for full details.
</p>
</details>

      <div class="button-row">
        <label for="pollutantSelect">Pollutant:</label>
        <select id="pollutantSelect" name="pollutantSelect"><option value="">Select pollutant</option></select>
      </div>
      <div id="groupContainer"></div>
      <details class="my-4 bg-gray-50 border border-gray-300 rounded-2xl p-4 shadow-sm">
  <summary class="cursor-pointer text-lg font-semibold text-blue-700 hover:text-blue-900">
    üìò See Group Info
  </summary>

  <div id="group-info" class="mt-3 text-gray-800 leading-relaxed overflow-x-auto">
    <p>Loading group information...</p>
  </div>
</details>
    </div>

    <div id="mainContentBottom">
      <div class="year-download-row">
        <span class="year-pair">
          <label for="startYear">Start Year:</label>
          <select id="startYear" name="startYear"></select>
        </span>
        <span class="year-pair">
          <label for="endYear">End Year:</label>
          <select id="endYear" name="endYear"></select>
        </span>
  <button id="downloadBtn">‚¨áÔ∏è Download Chart as PNG</button>
  <button id="downloadCleanBtn">‚¨áÔ∏è Download Clean PNG</button>
        <button id="toggleSmoothBtn">üö´ Disable Smoothing</button>
        <button id="downloadCSVBtn">üìÑ Download Data - CSV</button>
        <button id="downloadXLSXBtn">üìä Download Data - Excel</button>
        <button id="shareBtn">üîó Share Chart</button>
      </div>

      <div class="chart-wrapper">
        <div id="chartTitle" aria-hidden="false"></div>
        <div id="customLegend" aria-hidden="true"></div>
        <div id="chart_div" role="img" aria-label="Pollutant time series chart"></div>
      </div>
    </div>
<footer>
  ¬© Crown 2025 copyright Defra &amp; DESNZ via 
  <a href="https://naei.energysecurity.gov.uk" target="_blank" rel="noopener">naei.energysecurity.gov.uk</a> 
  licensed under the <a href="http://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" target="_blank" rel="noopener">Open Government Licence (OGL)</a>.
  <br>
  <strong>YouTube Channel:</strong> <a href="https://www.youtube.com/@ChronicIllnessChannel" target="_blank" rel="noopener">www.youtube.com/@ChronicIllnessChannel</a>
  <br>
  <span style="font-size: 0.8em; color: #666; margin-top: 4px; display: inline-block;">
    Version: v2.1 test (Supabase) ‚Ä¢ Build: 2025.10.27
  </span>
</footer>

  </div>

<script>
google.charts.load('current', {packages:['corechart']});

// Supabase project connection
const SUPABASE_URL = 'https://buqarqyqlugwaabuuyfy.supabase.co';
const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ1cWFycXlxbHVnd2FhYnV1eWZ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyOTczNDEsImV4cCI6MjA3Njg3MzM0MX0._zommN8QkzS0hY__N7KfuIaalKWG-PrSPq1BWg_BBjg';
const supabase = (window.supabase && window.supabase.createClient)
  ? window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY)
  : null;
let supabaseUnavailableLogged = false;

// Analytics tracking
let sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
let userFingerprint = null;
let userCountry = null;

// Get user's country (privacy-friendly timezone method)
function getUserCountry() {
  if (userCountry) return userCountry;
  
  try {
    // Get timezone and map to likely country
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const locale = navigator.language || 'en';
    
    // Simple mapping for common cases (privacy-friendly approach)
    const timezoneCountryMap = {
      'Europe/London': 'GB',
      'America/New_York': 'US', 'America/Chicago': 'US', 'America/Denver': 'US', 'America/Los_Angeles': 'US',
      'Europe/Paris': 'FR', 'Europe/Berlin': 'DE', 'Europe/Rome': 'IT', 'Europe/Madrid': 'ES',
      'Asia/Tokyo': 'JP', 'Asia/Shanghai': 'CN', 'Asia/Kolkata': 'IN',
      'Australia/Sydney': 'AU', 'Australia/Melbourne': 'AU',
      'America/Toronto': 'CA', 'America/Vancouver': 'CA'
    };
    
    userCountry = timezoneCountryMap[timezone] || locale.split('-')[1] || 'Unknown';
    return userCountry;
  } catch (e) {
    return 'Unknown';
  }
}

// Generate a privacy-friendly user fingerprint
function generateUserFingerprint() {
  if (userFingerprint) return userFingerprint;

  // Get or create persistent UUID for this browser
  let uuid = localStorage.getItem('naei_analytics_uuid');
  if (!uuid) {
    uuid = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
    localStorage.setItem('naei_analytics_uuid', uuid);
  }

  // Collect non-invasive browser info for analytics
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  ctx.textBaseline = 'top';
  ctx.font = '14px Arial';
  ctx.fillText('Browser fingerprint', 2, 2);
  const canvasData = canvas.toDataURL();

  const fingerprint = [
    uuid,
    navigator.userAgent,
    navigator.language,
    screen.width + 'x' + screen.height,
    new Date().getTimezoneOffset(),
    canvasData.slice(-50)
  ].join('|');

  // Hash it for privacy
  userFingerprint = btoa(fingerprint).substr(0, 24); // Slightly longer for more uniqueness
  return userFingerprint;
}

// Track analytics events
async function trackAnalytics(eventType, eventData = {}) {
  try {
    if (!eventType) return;

    if (!supabase) {
      if (!supabaseUnavailableLogged) {
        console.warn('Supabase client unavailable; analytics events will be skipped.');
        supabaseUnavailableLogged = true;
      }
      return;
    }

    const analyticsData = {
      session_id: sessionId,
      user_fingerprint: generateUserFingerprint(),
      event_type: eventType,
      event_data: {
        ...eventData,
        country: getUserCountry()
      },
      timestamp: new Date().toISOString(),
      user_agent: navigator.userAgent,
      page_url: window.location.href,
      referrer: document.referrer || null
    };

    console.log('üìä Analytics:', eventType, eventData);

    const { error } = await supabase
      .from('analytics_events')
      .insert([analyticsData]);

    if (error && !error.message?.includes('relation "analytics_events" does not exist')) {
      console.warn('Analytics tracking failed:', error);
    }
  } catch (err) {
    console.warn('Analytics error:', err);
  }
}

let globalRows=[], globalHeaders=[], pollutantUnits={}, groupedData={};
let allGroupsList = [];
let allPollutants = [];
let allGroups = [];
let pollutantsData = []; // Store raw pollutant data for ID lookups
let groupsData = []; // Store raw group data for ID lookups

const distinctPalette=['#E6194B','#3CB44B','#FFE119','#4363D8','#F58231','#911EB4','#46F0F0','#F032E6','#BCF60C','#FABEBE'];
const categoryBaseColor={ecodesign:distinctPalette[4],fireplace:distinctPalette[0],gas:distinctPalette[3],power:distinctPalette[1],road:distinctPalette[6]};
let colorCache={}, availableColors=[...distinctPalette];
let chart; // global chart instance
let seriesVisibility = [];
// Minimum export scale used when rasterizing SVG -> PNG. Increase this to
// get higher-res downloads. Change this value only when you're ready.
const EXPORT_MIN_SCALE = 16;

// Safety limits for exporting large images. Browsers will OOM or throw
// for extremely large canvas sizes; clamp export scales to conservative
// per-dimension and total-pixel limits.
const EXPORT_MAX_DIM = 16000; // max width or height in pixels (conservative)
const EXPORT_MAX_PIXELS = 100_000_000; // max total pixels (width * height)

/**
 * Compute a safe export scale that respects EXPORT_MAX_DIM and EXPORT_MAX_PIXELS.
 * origW/origH are the logical SVG/chart sizes in CSS pixels. desiredScale is
 * the requested scale (e.g. Math.max(devicePixelRatio, EXPORT_MIN_SCALE)).
 */
function computeSafeExportScale(origW, origH, desiredScale) {
  if (!origW || !origH || !isFinite(desiredScale) || desiredScale <= 0) return 1;
  // Max scale to keep each dimension under EXPORT_MAX_DIM
  const maxDimScale = Math.min(EXPORT_MAX_DIM / origW, EXPORT_MAX_DIM / origH);
  // Max scale to keep total pixels under EXPORT_MAX_PIXELS
  const maxAreaScale = Math.sqrt(EXPORT_MAX_PIXELS / (origW * origH));
  const allowed = Math.max(1, Math.min(desiredScale, maxDimScale, maxAreaScale));
  if (allowed < desiredScale) {
    console.warn(`Export scale ${desiredScale} reduced to ${allowed} to avoid huge canvas (${Math.round(origW*allowed)}x${Math.round(origH*allowed)})`);
    try {
      window.__export_debug = window.__export_debug || {};
      window.__export_debug.lastClamped = { origW, origH, desiredScale, allowed };
    } catch (e) {}
  }
  return allowed;
}
let smoothLines = true; // default to smooth (curved) lines


/* ---------------- Color helpers ---------------- */
function resetColorSystem() {
  colorCache = {};
  availableColors = [...distinctPalette];
}

function getColorForGroup(name) {
  if (!name) return '#888888';
  if (colorCache[name]) return colorCache[name];

  const lower = name.toLowerCase();
  const cat = Object.keys(categoryBaseColor).find(c => lower.includes(c));

  // Prefer category colour if available
  let baseColor = cat ? categoryBaseColor[cat] : null;
  let chosenColor = baseColor;

  // Avoid duplicates: if base colour already used, pick next available
  if (!chosenColor || Object.values(colorCache).includes(chosenColor)) {
    chosenColor = availableColors.find(c => !Object.values(colorCache).includes(c));
  }

  // Fallback to any colour if palette exhausted (shouldn't happen with ‚â§10)
  if (!chosenColor) {
    chosenColor = distinctPalette[Object.keys(colorCache).length % distinctPalette.length];
  }

  colorCache[name] = chosenColor;
  return chosenColor;
}


// --- Replace Google Sheets data load with Supabase ---
async function loadUnits() {
  const { data, error } = await supabase.from('NAEI_global_Pollutants').select('*');
  if (error) throw error;
  pollutantUnits = {};
  data.forEach(r => {
    if (r.Pollutant && r["Emission Unit"]) {
      pollutantUnits[r.Pollutant] = r["Emission Unit"];
    } else if (r.pollutant) {
      pollutantUnits[r.pollutant] = r["emission unit"] || r['Emission Unit'] || '';
    }
  });
}

async function loadData() {
  console.log("Fetching data from Supabase (separate tables for robustness)...");

  // Fetch pollutants, groups, and the timeseries table separately.
  const [pollutantsResp, groupsResp, dataResp] = await Promise.all([
    supabase.from('NAEI_global_Pollutants').select('*'),
    supabase.from('NAEI_global_t_Group').select('*'),
    supabase.from('NAEI_2023ds_t_Group_Data').select('*')  // Now fetches all rows due to project setting
  ]);

  if (pollutantsResp.error) throw pollutantsResp.error;
  if (groupsResp.error) throw groupsResp.error;
  if (dataResp.error) throw dataResp.error;

  const pollutants = pollutantsResp.data || [];
  const groups = groupsResp.data || [];
  const rows = dataResp.data || [];
  
  // Store globally for URL parameter lookups
  pollutantsData = pollutants;
  groupsData = groups;

  // Build ID -> name maps for joins
  const pollutantIdToName = {};
  pollutants.forEach(p => {
    const id = p.id;
    const name = p.Pollutant || p.pollutant || p['Pollutant'] || p['pollutant'];
    if (name) {
      pollutantIdToName[id] = name;
      // capture unit if present
      const unit = p["Emission Unit"] || p["emission unit"] || p['Emission Unit'] || p.emission_unit || '';
      if (unit) pollutantUnits[name] = unit;
    }
  });

  const groupIdToTitle = {};
  groups.forEach(g => {
    const id = g.id;
    const title = g.Group_Title || g.group_title || g['Group_Title'] || g.group_title;
    if (title) groupIdToTitle[id] = title;
  });
  


  // Build lists used for dropdowns
  allPollutants = [...new Set(Object.values(pollutantIdToName).filter(Boolean))].sort();
  allGroups = [...new Set(Object.values(groupIdToTitle).filter(Boolean))].sort((a, b) => {
    if (a.toLowerCase() === "all") return -1;
    if (b.toLowerCase() === "all") return 1;
    return a.localeCompare(b);
  });

  window.allGroupsList = allGroups;
  window.allPollutants = allPollutants;

  // Determine year headers from data rows (look for fYYYY fields)
  if (!rows || rows.length === 0) {
    // no timeseries rows ‚Äî still return groups/pollutants for dropdowns
    window.globalHeaders = [];
    window.globalYears = [];
    window.globalYearKeys = [];
    groupedData = {};
    console.log('No timeseries rows found in NAEI_2023ds_t_Group_Data');
    return;
  }

  // ensure consistent header ordering (f1970 ... f2023)
  const sample = rows[0];
  const headers = Object.keys(sample).filter(k => /^f\d{4}$/.test(k)).sort((a,b)=> +a.slice(1) - +b.slice(1));
  window.globalHeaders = headers;
  window.globalYears = headers.map(h => h.slice(1));
  window.globalYearKeys = headers;

  // Build groupedData using FK ids and the lookup maps
  groupedData = {};
  rows.forEach(r => {
    const polId = r.Pollutant_id ?? r.pollutant_id ?? r.PollutantId ?? r.pollutantid;
    const grpId = r.Group_id ?? r.group_id ?? r.GroupId ?? r.groupid;
    const polName = pollutantIdToName[polId];
    const grpName = groupIdToTitle[grpId];
    if (!polName || !grpName) return;
    if (!groupedData[polName]) groupedData[polName] = {};
    groupedData[polName][grpName] = r;
  });

  // If the groups table didn't provide titles (or permissions prevented access), fall back to groups
  // discovered in the timeseries rows themselves
  const groupsFromData = [...new Set(Object.values(groupedData).flatMap(pol => Object.keys(pol)))];
  if ((!allGroups || allGroups.length === 0) && groupsFromData.length) {
    allGroups = groupsFromData.sort((a, b) => {
      if (a.toLowerCase() === "all") return -1;
      if (b.toLowerCase() === "all") return 1;
      return a.localeCompare(b);
    });
    window.allGroupsList = allGroups;
    console.warn('Groups list was empty from NAEI_global_t_Group ‚Äî falling back to groups found in timeseries rows.');
  }

  console.log(`Loaded ${rows.length} timeseries rows; ${allPollutants.length} pollutants; ${allGroups.length} groups`);
}


/* ---------------- UI: selectors & group controls ---------------- */
function setupSelectors(){
  // ‚úÖ Use pollutant list from Supabase loadData
  const sel = document.getElementById('pollutantSelect');
  sel.innerHTML = '<option value="">Select pollutant</option>';
  if (window.allPollutants && window.allPollutants.length) {
    window.allPollutants.forEach(p => sel.add(new Option(p, p)));
  }

  // Ensure we have the groups list available from the global window var
  if (!window.allGroupsList && window.allGroups) {
    window.allGroupsList = window.allGroups;
  }


  // ‚úÖ Use precomputed globalYears instead of header slice
  const years = window.globalYears || [];
  const startSel = document.getElementById('startYear');
  const endSel = document.getElementById('endYear');

  startSel.innerHTML = '';
  endSel.innerHTML = '';

  years.forEach(y => {
    startSel.add(new Option(y, y));
    endSel.add(new Option(y, y));
  });

  startSel.value = years[0] || '';
  endSel.value = years[years.length - 1] || '';

  sel.addEventListener('change', updateChart);
  startSel.addEventListener('change', updateChart);
  endSel.addEventListener('change', updateChart);

  // Group selectors will be added by the init() function after URL parameter processing
  // This prevents double group creation that causes visual jumping
 }

function getSelectedGroups(){ return [...document.querySelectorAll('#groupContainer select')].map(s => s.value).filter(Boolean); }
function addGroupSelector(defaultValue = "", usePlaceholder = true){
  const container = document.getElementById('groupContainer');
  const div = document.createElement('div');
  div.className = 'groupRow';
  div.draggable = true;

  // drag handle
  const dragHandle = document.createElement('span');
  dragHandle.className = 'dragHandle';
  dragHandle.textContent = '‚†ø';
  dragHandle.style.marginRight = '6px';
  // group control wrapper (keeps drag handle and select together)
  const controlWrap = document.createElement('div');
  controlWrap.className = 'group-control';

  // convert drag handle into an accessible button so it's keyboard-focusable
  const handleBtn = document.createElement('button');
  handleBtn.type = 'button';
  handleBtn.className = 'dragHandle';
  handleBtn.setAttribute('aria-label', 'Reorder group (use arrow keys)');
  handleBtn.title = 'Drag to reorder (or focus and use Arrow keys)';
  handleBtn.textContent = '‚†ø';
  handleBtn.style.marginRight = '6px';
  controlWrap.appendChild(handleBtn);

  // group select
  const sel = document.createElement('select');
  sel.setAttribute('aria-label', 'Group selector');
  sel.name = 'groupSelector';
  if (usePlaceholder){
    const ph = new Option('Select group','');
    ph.disabled = true; ph.selected = true;
    sel.add(ph);
  }
  const allGroups = window.allGroupsList || [];

  const selected = getSelectedGroups();
  allGroups.forEach(g => {
    if (!selected.includes(g) || g === defaultValue) sel.add(new Option(g,g));
  });
  if (defaultValue) sel.value = defaultValue;
  sel.addEventListener('change', () => { refreshGroupDropdowns(); updateChart(); });

  controlWrap.appendChild(sel);
  // append the control wrap first; remove button will be appended to row as a sibling
  div.appendChild(controlWrap);

  // keyboard handlers for reordering when handleBtn is focused
  handleBtn.addEventListener('keydown', (e) => {
    try {
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        let prev = div.previousElementSibling;
        while (prev && !prev.classList.contains('groupRow')) prev = prev.previousElementSibling;
        if (prev) {
          container.insertBefore(div, prev);
          refreshGroupDropdowns();
          refreshButtons();
          updateChart();
          // move focus back to the handle for continued keyboard moves
          handleBtn.focus();
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        let next = div.nextElementSibling;
        while (next && !next.classList.contains('groupRow')) next = next.nextElementSibling;
        if (next) {
          container.insertBefore(div, next.nextElementSibling);
          refreshGroupDropdowns();
          refreshButtons();
          updateChart();
          handleBtn.focus();
        }
      }
    } catch (err) {
      console.warn('Keyboard reorder failed', err);
    }
  });

  container.appendChild(div);
  addDragAndDropHandlers(div);
  refreshButtons();
}

function refreshGroupDropdowns(){
  const selected = getSelectedGroups();
  const all = window.allGroupsList || [];


  document.querySelectorAll('#groupContainer select').forEach(select => {
    const current = select.value;
    Array.from(select.options).forEach(opt => { if (opt.value !== '') opt.remove(); });
    all.forEach(g => {
      if (!selected.includes(g) || g === current) {
        const option = new Option(g,g);
        if (g === current) option.selected = true;
        select.add(option);
      }
    });
  });
}

function refreshButtons() {
  const container = document.getElementById('groupContainer');
  // Remove any existing Add/Remove buttons to rebuild cleanly
  container.querySelectorAll('.add-btn, .remove-btn').forEach(n => n.remove());

  const rows = container.querySelectorAll('.groupRow');

  // Add remove buttons only if there are 2 or more groups
    if (rows.length >= 2) {
    rows.forEach(row => {
        if (!row.querySelector('.remove-btn')) {
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-btn';
  removeBtn.innerHTML = '<span class="remove-icon">‚àí</span> Remove Group';
        // make ARIA label include the current group name if available
        const sel = row.querySelector('select');
        const groupName = sel ? (sel.value || (sel.options[sel.selectedIndex] && sel.options[sel.selectedIndex].text) || '') : '';
        removeBtn.setAttribute('aria-label', groupName ? `Remove group ${groupName}` : 'Remove group');
        removeBtn.onclick = () => {
          row.remove();
          refreshButtons();
          refreshGroupDropdowns();
          updateChart();
        };
        // Append remove button as a sibling to the control wrapper so it
        // sits inline on wide screens but drops underneath on small screens
        row.appendChild(removeBtn);
      }
    });
  }

  // Add "Add Group" button just below the last group box
  let addBtn = container.querySelector('.add-btn');
  if (!addBtn) {
    addBtn = document.createElement('button');
    addBtn.className = 'add-btn';
    addBtn.innerHTML = '<span class="add-icon">+</span> Add Group';
    addBtn.onclick = () => addGroupSelector("", true);
    container.appendChild(addBtn);
  }

  // Disable button if 10 groups are present
  if (rows.length >= 10) {
    addBtn.textContent = 'Max Groups = 10';
    addBtn.disabled = true;
  } else {
    addBtn.innerHTML = '<span class="add-icon">+</span> Add Group';
    addBtn.disabled = false;
  }
}

function calculateYearTicks(years, chartWidth) {
  // Deterministic tick selection: evenly sample years to avoid overlap and shifting
  if (!years || !years.length) return [];

  const uniqueYears = [...new Set(years.map(y => String(y)))];
  if (uniqueYears.length <= 1) return uniqueYears;

  // For small number of years, show all
  if (uniqueYears.length <= 10) return uniqueYears;

  const minSpacing = 60; // px between labels
  const maxLabels = Math.max(2, Math.floor(chartWidth / minSpacing));

  if (uniqueYears.length <= maxLabels) return uniqueYears;

  const step = Math.ceil(uniqueYears.length / maxLabels);
  const result = uniqueYears.filter((y, idx) => idx % step === 0);

  // Always include last year
  const lastYear = uniqueYears[uniqueYears.length - 1];
  if (result[result.length - 1] !== lastYear) result.push(lastYear);

  return result;
}

/**
 * Remove bare 4-digit year tick elements from an SVG root unless they're
 * explicitly marked with `data-custom-year`. Returns an object listing
 * removed labels for diagnostics.
 */
function pruneYearsFromSVG(svgRoot, opts = {}) {
  const debug = opts.debug || false;
  const removed = [];
  try {
    if (!svgRoot || !svgRoot.querySelectorAll) return { removed };
    const nodes = svgRoot.querySelectorAll('text, tspan');
    nodes.forEach(node => {
      try {
        const txt = (node.textContent || '').trim();
        if (/^\d{4}$/.test(txt)) {
          let cur = node;
          let hasCustom = false;
          while (cur && cur.getAttribute) {
            if (cur.getAttribute('data-custom-year')) { hasCustom = true; break; }
            cur = cur.parentNode;
          }
          if (!hasCustom) {
            let toRemove = node;
            while (toRemove && toRemove.nodeName && toRemove.nodeName.toLowerCase() !== 'text') toRemove = toRemove.parentNode;
            if (toRemove && toRemove.parentNode) {
              toRemove.parentNode.removeChild(toRemove);
              removed.push(txt);
            }
          }
        }
      } catch (e) {
        if (debug) console.warn('pruneYearsFromSVG inner error', e);
      }
    });
  } catch (e) {
    if (debug) console.warn('pruneYearsFromSVG failed', e);
  }
  return { removed };
}

/* ---------------- Drag and drop handlers ---------------- */
function addDragAndDropHandlers(div){
  div.addEventListener('dragstart', e => {
    e.dataTransfer.setData('text/plain', '');
    div.classList.add('dragging');
  });
  div.addEventListener('dragend', () => div.classList.remove('dragging'));
  div.addEventListener('dragover', e => {
    e.preventDefault();
    const container = document.getElementById('groupContainer');
    const dragging = container.querySelector('.dragging');
    if (!dragging) return;
    const after = getDragAfterElement(container, e.clientY);
    const addBtn = container.querySelector('.add-btn');
    if (!after || after === addBtn) container.insertBefore(dragging, addBtn);
    else container.insertBefore(dragging, after);
  });
  div.addEventListener('drop', () => { refreshGroupDropdowns(); updateChart(); });
}

function getDragAfterElement(container, y){
  const draggable = [...container.querySelectorAll('.groupRow:not(.dragging)')];
  return draggable.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) return { offset: offset, element: child };
    return closest;
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

/* ---------------- Chart rendering & legend ---------------- */
function updateChart(){
  const pollutant = document.getElementById('pollutantSelect').value;
  const startYear = +document.getElementById('startYear').value;
  const endYear = +document.getElementById('endYear').value;
  const groups = getSelectedGroups();
  if (!pollutant || !startYear || !endYear || !groups.length) return;

  // Track chart view analytics
  trackAnalytics('chart_view', {
    pollutant: pollutant,
    start_year: startYear,
    end_year: endYear,
    groups: groups,
    groups_count: groups.length,
    year_range: endYear - startYear + 1
  });

  resetColorSystem();
  // Use the global year keys to determine which years to display
  const yearsAll = window.globalYears || [];
  const yearKeys = window.globalYearKeys || [];
  const startIdx = yearsAll.indexOf(String(startYear));
  const endIdx = yearsAll.indexOf(String(endYear));
  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) return;
  const years = yearsAll.slice(startIdx, endIdx + 1);
  const keysForYears = yearKeys.slice(startIdx, endIdx + 1);
  const colors = groups.map(g => getColorForGroup(g));

  // Build rows of data (year + series values). Use null for missing.
  const chartRows = years.map((y, rowIdx) => {
    const row = [y];
    const key = keysForYears[rowIdx]; // e.g. 'f2015'
    groups.forEach(g => {
      const dataRow = groupedData[pollutant]?.[g];
      const raw = dataRow ? dataRow[key] : null;
      const val = (raw === null || raw === undefined) ? null : parseFloat(raw);
      row.push(Number.isNaN(val) ? null : val);
    });
    return row;
  });

  // guard against empty data
  if (chartRows.length === 0) return;

  // --- Determine which groups actually have data ---
  const groupHasData = groups.map((g, i) => {
    return chartRows.some(row => typeof row[i + 1] === 'number');
  });

  // Create DataTable explicitly to guarantee column types
  const dataTable = new google.visualization.DataTable();
  dataTable.addColumn('string', 'Year');           // year as string
  groups.forEach(g => dataTable.addColumn('number', g)); // explicit numeric series columns
  dataTable.addRows(chartRows);

  const unit = pollutantUnits[pollutant] || "";
  const seriesOptions = {};
  groups.forEach((g, i) => {
    seriesOptions[i] = { color: colors[i], lineWidth: 3, pointSize: 4 };
  });

  // Estimate left margin dynamically based on Y-axis label width
  const maxValue = Math.max(
    ...chartRows.flatMap(r => r.slice(1).filter(v => typeof v === "number"))
  );
  const labelLength = maxValue ? maxValue.toLocaleString().length : 3;
  const leftMargin = Math.min(100, Math.max(60, labelLength * 10)); // dynamic left padding

  const chartContainer = document.getElementById('chart_div');

  const options = {
    title: '',
    width: '100%',
    height: '70%',
    legend: 'none',
    hAxis: {
      title: 'Year',
      textStyle: { color: 'transparent' }, // Hide Google Charts labels
      titleTextStyle: { fontSize: 13, bold: true },
      gridlines: { color: '#e0e0e0' },
      baselineColor: '#666'
    },
    vAxis: {
      title: `Emissions${unit ? " (" + unit + ")" : ""}`,
      viewWindow: { min: 0 },
      textStyle: { fontSize: 12 },
      titleTextStyle: { fontSize: 13, bold: true }
    },
    series: seriesOptions,
    curveType: smoothLines ? 'function' : 'none',
    lineWidth: 3,
    pointSize: 4,
    chartArea: {
      top: 20,
      left: leftMargin,
      right: 10,
      bottom: 60,
      height: '70%'
    }
  };
  

  // draw chart and show pollutant as visible page title
  chart = new google.visualization.LineChart(chartContainer);

  // Compute safe width/height to avoid negative SVG dimensions
  const safeWidth = Math.max(chartContainer.offsetWidth || 0, 300);
  const safeHeight = Math.max(chartContainer.offsetHeight || 0, 200);
  options.width = safeWidth;
  options.height = safeHeight;

  // On mobile, show only first and last year for clarity
  const isMobile = window.innerWidth < 600;
  if (isMobile) {
    options.hAxis.slantedText = true;
    options.hAxis.slantedTextAngle = 90;
  }
    // Ensure a small right chart padding so the chart fills most of the container
  if (options.chartArea) {
    // Reduce the minimum right padding; previously set to 80px which left a large gap.
    options.chartArea.right = Math.max(options.chartArea.right || 10, 20);
    if (isMobile) {
      options.chartArea.width = '70%';
    }
  }

  // Delay slightly to let layout stabilize (prevents negative sizes)
  setTimeout(() => {
    chart.draw(dataTable, options);
    chartContainer.classList.add('visible');
    
    // Manually add custom year labels with proper spacing
    setTimeout(() => {
      try {
        const svg = chartContainer.querySelector('svg');
        if (!svg) return;
        
        const chartLayout = chart.getChartLayoutInterface();
        const chartArea = chartLayout.getChartAreaBoundingBox();
        const labelY = chartArea.top + chartArea.height + 20;
        const ns = 'http://www.w3.org/2000/svg';
        
          // Use calculateYearTicks to determine which years to show
        const chartWidth = chartArea.width;
        const labelsToShow = calculateYearTicks(years, chartWidth);
        
        // Get all x positions first to check for overlaps
        const positions = [];
        const labels = [];
        const minSpacing = 40; // Minimum pixels between labels
        
          // First pass: collect all positions
        for (const year of labelsToShow) {
          const yearIndex = years.indexOf(year);
          const x = chartLayout.getXLocation(yearIndex);
          positions.push(x);
          
          const text = document.createElementNS(ns, 'text');
          text.setAttribute('x', x);
          text.setAttribute('y', labelY);
          text.setAttribute('text-anchor', 'middle');
          text.setAttribute('font-family', 'Arial, sans-serif');
          // Keep on-screen labels slightly smaller / lighter so they look correct in the UI.
          // We draw larger labels onto the export canvas when necessary.
          text.setAttribute('font-size', '14');
          text.setAttribute('font-weight', '500');
          text.setAttribute('fill', '#333');
          // Mark custom year labels so export can distinguish them from default axis ticks
          text.setAttribute('data-custom-year', 'true');
          text.textContent = year;
          
          // Store for later use
          labels.push({
            element: text,
            x: x,
            year: year
          });
        }
        
        // If the penultimate label is too close to the final label, drop it
        if (labels.length >= 2) {
          const lastIdx = labels.length - 1;
          const lastX = parseFloat(labels[lastIdx].x || labels[lastIdx].element.getAttribute('x'));
          const prevX = parseFloat(labels[lastIdx - 1].x || labels[lastIdx - 1].element.getAttribute('x'));
          if ((lastX - prevX) < minSpacing) {
            // remove penultimate label so final label isn't crowded
            labels.splice(lastIdx - 1, 1);
          }
        }

        // Second pass: adjust positions to prevent overlap
        for (let i = 1; i < labels.length; i++) {
          const prevX = parseFloat(labels[i-1].element.getAttribute('x'));
          const currentX = labels[i].x;
          
          // If labels are too close, adjust the current label's position
          if (Math.abs(currentX - prevX) < minSpacing) {
            // Move the current label to the right of the previous one
            const newX = prevX + minSpacing;
            // But don't go beyond the chart area
            if (newX < chartArea.left + chartArea.width - 20) {
              labels[i].element.setAttribute('x', newX);
              // Update the text-anchor to 'start' to prevent text from shifting
              labels[i].element.setAttribute('text-anchor', 'start');
            }
          }
        }
        
        // Add all labels to the SVG
        labels.forEach(label => {
          svg.appendChild(label.element);
        });
      } catch (e) {
        console.warn('Could not add custom year labels:', e);
      }
    }, 150);
  }, 100);

  // update visible title on page
  const titleEl = document.getElementById('chartTitle');
  titleEl.textContent = `${pollutant}${unit ? " (" + unit + ")" : ""}`;

  // build custom legend (interactive)
  const legendDiv = document.getElementById('customLegend');
  legendDiv.innerHTML = '';
  const seriesVisibility = Array(groups.length).fill(true);

  groups.forEach((g, i) => {
    const item = document.createElement('span');
    const dot = document.createElement('span');
    dot.style.display = 'inline-block';
    dot.style.width = '12px';
    dot.style.height = '12px';
    dot.style.borderRadius = '50%';
    dot.style.backgroundColor = colors[i];
    item.appendChild(dot);

    const labelText = document.createTextNode(g + (groupHasData[i] ? '' : ' (No data available)'));
    item.appendChild(labelText);

    // Fade if no data
    if (!groupHasData[i]) {
      item.style.opacity = '0.4';
      item.title = 'No data available';
    }

    // Toggle visibility only if data exists
    if (groupHasData[i]) {
      item.addEventListener('click', () => {
        seriesVisibility[i] = !seriesVisibility[i];
        const newOptions = { ...options, series: {} };
        groups.forEach((g2, idx) => {
          newOptions.series[idx] = seriesVisibility[idx]
            ? { color: colors[idx], lineWidth: 3, pointSize: 4 }
            : { color: colors[idx], lineWidth: 0, pointSize: 0 };
        });
        chart.draw(dataTable, newOptions);
        item.style.opacity = seriesVisibility[i] ? '1' : '0.4';
      });
    }

    legendDiv.appendChild(item);
  });

  // ensure controls reflect available choices
  refreshGroupDropdowns();
  refreshButtons();
}

window.addEventListener('resize', () => {
  clearTimeout(window._resizeTimer);
  window._resizeTimer = setTimeout(updateChart, 200);
});

async function renderInitialView() {
  return new Promise(resolve => {
    requestAnimationFrame(() => {
      try {
        updateChart();
      } catch (err) {
        console.error('Initial chart render failed:', err);
      } finally {
        setTimeout(resolve, 350);
      }
    });
  });
}

async function revealMainContent() {
  const overlay = document.getElementById('loadingOverlay');
  const content = document.getElementById('mainContent');
  if (!overlay || !content) return;

  content.style.display = 'block';
  content.removeAttribute('aria-hidden');
  requestAnimationFrame(() => content.classList.add('loaded'));

  await renderInitialView();

  overlay.style.opacity = '0';

  return new Promise(resolve => {
    setTimeout(() => {
      overlay.style.display = 'none';
      resolve();
    }, 400);
  });
}

function setupDownloadButton() {
  const dl = document.getElementById('downloadBtn');

  dl.addEventListener('click', async () => {
    const pollutant = document.getElementById('pollutantSelect').value;
    if (!chart || !pollutant) return;

    // Track chart download analytics
    const selectedGroups = getSelectedGroups();
    const startYear = +document.getElementById('startYear').value;
    const endYear = +document.getElementById('endYear').value;
    trackAnalytics('chart_download', {
      pollutant: pollutant,
      start_year: startYear,
      end_year: endYear,
      groups: selectedGroups,
      groups_count: selectedGroups.length,
      filename: pollutant.replace(/[^a-z0-9_\-]/gi, '_') + '_comparison.png'
    });

    const unit = pollutantUnits[pollutant] || "";

    // Create a bitmap from an offscreen Google chart (returns a Promise resolving to data URI).
    
/**
 * Render a fresh offscreen Google Chart into a hidden container, return a high-DPI PNG data URI.
 *
 * Parameters must match how you call it currently:
 * pollutant, selectedGroups, startYear, endYear, pixelW, pixelH, smoothLines
 *
 * Important: this function explicitly sets chart options (chartArea, axis fonts, hAxis ticks)
 * to match the on-screen chart's visual layout so the bitmap matches exactly.
 */
async function getOffscreenChartImageURI(
  pollutant,
  selectedGroups,
  startYear,
  endYear,
  pixelW,
  pixelH,
  smoothLines
) {
  return new Promise((resolve, reject) => {
    try {
      // Create offscreen container
      const off = document.createElement('div');
      off.style.position = 'fixed';
      off.style.left = '-99999px';
      off.style.top = '0';
      off.style.width = Math.round(pixelW / (window.devicePixelRatio || 1)) + 'px';
      off.style.height = Math.round(pixelH / (window.devicePixelRatio || 1)) + 'px';
      off.style.opacity = '0';
      off.id = 'offscreen_chart_export';
      document.body.appendChild(off);

      // Build the same DataTable you use for the on-screen chart.
      // IMPORTANT: this assumes you have a helper `buildChartDataTable(...)` that returns a google.visualization.DataTable
      // If you don't, inline the code you already use to create the data table.
      let dt;
      try {
        dt = buildChartDataTable(pollutant, selectedGroups, startYear, endYear);
      } catch (errDt) {
        console.warn('getOffscreenChartImageURI: falling back to global dataTable or chart.getDataTable', errDt);
        try { dt = chart && chart.getDataTable && chart.getDataTable(); } catch (e) { dt = null; }
      }
      if (!dt) {
        // If we cannot build the table, bail: resolve null so caller falls back.
        document.body.removeChild(off);
        return resolve(null);
      }

      // Compute axis ticks (ensure they match the custom year labels you draw on-screen).
      // If you already compute `yearTicks` elsewhere (array of numbers), reuse it; otherwise generate one:
      let yearTicks = [];
      if (typeof getYearTickArray === 'function') {
        try { yearTicks = getYearTickArray(startYear, endYear); } catch (e) { yearTicks = []; }
      }
      if (!yearTicks || !yearTicks.length) {
        // fallback: pick a reasonable ticks set between start and end
        const s = parseInt(startYear, 10), e = parseInt(endYear, 10);
        if (!isNaN(s) && !isNaN(e)) {
          const span = Math.max(1, e - s);
          // choose ~10 ticks across span
          const step = Math.max(1, Math.round(span / 10));
          for (let y = s; y <= e; y += step) yearTicks.push(y);
          if (yearTicks[yearTicks.length-1] !== e) yearTicks.push(e);
        }
      }

      // Chart options - make these match your on-screen options exactly.
      const dpr = window.devicePixelRatio || 1;
      const logicalW = Math.round(pixelW / dpr);
      const logicalH = Math.round(pixelH / dpr);

      const chartOptions = {
        // Use same font sizes and chartArea as on-screen (tweak if your on-screen differs)
        chartArea: {
          left: 70,
          top: 40,
          width: logicalW - 140,
          height: logicalH - 140
        },
        height: logicalH,
        width: logicalW,
        backgroundColor: '#ffffff',
        legend: { position: 'none' },
        hAxis: {
          ticks: yearTicks.map(y => ({ v: Number(y), f: String(y) })),
          textStyle: { fontSize: 12 },
          baselineColor: '#000000',
          gridlines: { color: '#e9e9e9', count: 0 }
        },
        vAxis: {
          textStyle: { fontSize: 12 },
          gridlines: { color: '#e9e9e9', count: 10 },
          baselineColor: '#000000'
        },
        series: {},
        pointSize: 5,
        curveType: smoothLines ? 'function' : 'none',
        tooltip: { trigger: 'none' },
        enableInteractivity: false
      };

      // Draw chart
      const offChart = new google.visualization.LineChart(off);
      google.visualization.events.addListener(offChart, 'ready', function () {
        try {
          let dataUri;
          try {
            dataUri = offChart.getImageURI();
          } catch (eGet) {
            console.warn('offChart.getImageURI failed', eGet);
            dataUri = null;
          }

          if (!dataUri) {
            document.body.removeChild(off);
            return resolve(null);
          }

          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = function () {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = pixelW;
              canvas.height = pixelH;
              const ctx = canvas.getContext('2d');

              ctx.fillStyle = '#ffffff';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Draw rasterized chart image without browser smoothing for crisper lines
              try {
                const prevSmoothing = typeof ctx.imageSmoothingEnabled !== 'undefined' ? ctx.imageSmoothingEnabled : null;
                try { ctx.imageSmoothingEnabled = false; } catch (e) {}
                try { ctx.webkitImageSmoothingEnabled = false; } catch (e) {}
                try { ctx.mozImageSmoothingEnabled = false; } catch (e) {}
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                if (prevSmoothing !== null) try { ctx.imageSmoothingEnabled = prevSmoothing; } catch (e) {}
              } catch (eS) {
                // Fallback to normal draw if the smoothing toggle failed
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              }

              const finalUri = canvas.toDataURL('image/png');
              try { document.body.removeChild(off); } catch (e) {}
              return resolve(finalUri);
            } catch (eDraw) {
              console.error('getOffscreenChartImageURI: draw error', eDraw);
              try { document.body.removeChild(off); } catch (e) {}
              return resolve(null);
            }
          };
          img.onerror = function (err) {
            console.warn('getOffscreenChartImageURI: image load failed', err);
            try { document.body.removeChild(off); } catch (e) {}
            return resolve(null);
          };
          img.src = dataUri;
        } catch (errReady) {
          console.error('getOffscreenChartImageURI: ready handler error', errReady);
          try { document.body.removeChild(off); } catch (e) {}
          return resolve(null);
        }
      });

      offChart.draw(dt, chartOptions);

      setTimeout(() => {
        if (document.getElementById('offscreen_chart_export')) {
          try { document.body.removeChild(document.getElementById('offscreen_chart_export')); } catch (e) {}
          resolve(null);
        }
      }, 2500);

    } catch (err) {
      console.error('getOffscreenChartImageURI: error', err);
      try { document.getElementById('offscreen_chart_export') && document.body.removeChild(document.getElementById('offscreen_chart_export')); } catch (e) {}
      resolve(null);
    }
  });
}
    
    // Render chart SVG at a higher pixel density to improve exported PNG quality
    const chartContainer = document.getElementById('chart_div');
    const svgEl = chartContainer ? chartContainer.querySelector('svg') : null;
    const origW = svgEl ? (parseInt(svgEl.getAttribute('width')) || chartContainer.offsetWidth || 800) : (chartContainer ? chartContainer.offsetWidth : 800);
    const origH = svgEl ? (parseInt(svgEl.getAttribute('height')) || chartContainer.offsetHeight || 400) : (chartContainer ? chartContainer.offsetHeight : 400);
    const exportScale = computeSafeExportScale(origW, origH, Math.max(window.devicePixelRatio || 1, EXPORT_MIN_SCALE)); // at least EXPORT_MIN_SCALE for crisp lines
    let img = new Image();
    img.crossOrigin = 'anonymous';

    // img.onload handler moved up so we can set img.src from async helpers
    img.onload = () => {
      // --- Measure legend for layout ---
      const legendClone = document.getElementById('customLegend').cloneNode(true);
      legendClone.style.position = 'absolute';
      legendClone.style.visibility = 'hidden';
      const logoSize = 80;
      const padding = 20;
      const maxLegendWidth = Math.max(100, origW - padding * 2 - logoSize - 20);
      legendClone.style.width = Math.min(800, maxLegendWidth) + 'px';
      document.body.appendChild(legendClone);
      const legendHeight = legendClone.offsetHeight + 10;
      document.body.removeChild(legendClone);

      const titleHeight = 30;
      const footerHeight = 40;

      // --- Auto-scale for print quality ---
      const targetWidth = 3508;
      const logicalWidth = origW + padding * 2;
      const logicalHeight = origH + titleHeight + legendHeight + footerHeight + padding * 3;
      const scale = targetWidth / logicalWidth;

      const canvas = document.createElement('canvas');
      canvas.width = Math.round(logicalWidth * scale);
      canvas.height = Math.round(logicalHeight * scale);
      const ctx = canvas.getContext('2d');
      ctx.scale(scale, scale);

      // --- Background ---
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, logicalWidth, logicalHeight);

      // --- Title ---
      ctx.font = 'bold 18px system-ui, sans-serif';
      ctx.fillStyle = '#000000';
      ctx.textAlign = 'center';
      ctx.fillText(
        `${pollutant}${unit ? " (" + unit + ")" : ""}`,
        logicalWidth / 2,
        padding + 15
      );

      // --- Legend ---
      const legendDiv = document.getElementById('customLegend');
      const items = [...legendDiv.querySelectorAll('span')];
      let legendY = padding + 35;
      const legendRowHeight = 22;
      const maxW = logicalWidth - padding * 2;
      const rowItems = [];
      let row = [],
        rowW = 0;

      items.forEach((it) => {
        const dot = it.querySelector('span');
        if (!dot) return;
        const text = it.textContent.trim();
        ctx.font = '600 14px system-ui, sans-serif';
        const textW = ctx.measureText(text).width;
        const w = textW + 40;
        if (rowW + w > maxW && row.length) {
          rowItems.push({ row, rowW });
          row = [];
          rowW = 0;
        }
        row.push({ dotColor: dot.style.backgroundColor, text });
        rowW += w;
      });

      if (row.length) rowItems.push({ row, rowW });

      rowItems.forEach(({ row, rowW }) => {
        let x = (logicalWidth - rowW) / 2;
	row.forEach(({ dotColor, text }) => {
	  const faded = text.includes('(No data available)');
	  ctx.globalAlpha = faded ? 0.4 : 1.0;
	  ctx.beginPath();
	  ctx.arc(x + 6, legendY - 5, 6, 0, 2 * Math.PI);
	  ctx.fillStyle = dotColor;
	  ctx.fill();
	  ctx.font = '600 14px system-ui, sans-serif';
	  ctx.fillStyle = '#000000';
	  ctx.textAlign = 'left';
	  ctx.fillText(text, x + 18, legendY);
	  ctx.globalAlpha = 1.0;
	  x += ctx.measureText(text).width + 40;
	});
        legendY += legendRowHeight;
      });

      // --- Chart image ---
      try {
        const prevSmoothing = typeof ctx.imageSmoothingEnabled !== 'undefined' ? ctx.imageSmoothingEnabled : null;
        try { ctx.imageSmoothingEnabled = false; } catch (e) {}
        try { ctx.webkitImageSmoothingEnabled = false; } catch (e) {}
        try { ctx.mozImageSmoothingEnabled = false; } catch (e) {}
        ctx.drawImage(img, padding, legendY + 10, origW, origH);
        if (prevSmoothing !== null) try { ctx.imageSmoothingEnabled = prevSmoothing; } catch (e) {}
      } catch (eS) {
        ctx.drawImage(img, padding, legendY + 10, origW, origH);
      }

      // --- Logo and footer ---
      const logo = new Image();
      logo.crossOrigin = 'anonymous';
      logo.src = 'CIC - Square - Border - Words - Alpha 360x360.png';

	  const finishExport = () => {
	          const footerText =
	            "¬© Crown 2025 copyright Defra & DESNZ via naei.energysecurity.gov.uk licensed under the Open Government Licence (OGL).";
	          const channelText = "Youtube Channel: youtube.com/@chronicillnesschannel";

	          // --- Footer text wrapping ---
	          ctx.font = '12px system-ui, sans-serif';
	          ctx.fillStyle = '#555';
	          ctx.textAlign = 'center';
	          const maxFooterWidth = logicalWidth - 40;
	          function wrapText(text, maxWidth) {
	            const words = text.split(' ');
	            let lines = [], line = '';
	            for (let n = 0; n < words.length; n++) {
	              const testLine = line + (line ? ' ' : '') + words[n];
	              const metrics = ctx.measureText(testLine);
	              if (metrics.width > maxWidth && line) {
	                lines.push(line);
	                line = words[n];
	              } else {
	                line = testLine;
	              }
	            }
	            if (line) lines.push(line);
	            return lines;
	          }
	          const footerLines = wrapText(footerText, maxFooterWidth);
	          let footerY = legendY + 10 + origH + 20;
	          footerLines.forEach((line, i) => {
	            ctx.fillText(line, logicalWidth / 2, footerY + i * 16);
	          });
	          footerY += footerLines.length * 16;

	          // Draw YouTube channel with bold label
	          const boldText = "Youtube Channel: ";
	          const normalText = "youtube.com/@chronicillnesschannel";
	          ctx.font = 'bold 12px system-ui, sans-serif';
	          const boldWidth = ctx.measureText(boldText).width;
	          ctx.font = '12px system-ui, sans-serif';
	          const normalWidth = ctx.measureText(normalText).width;
	          const totalWidth = boldWidth + normalWidth;
	          let channelY = footerY + 5;
	          ctx.font = 'bold 12px system-ui, sans-serif';
	          ctx.fillText(boldText, (logicalWidth - totalWidth) / 2 + boldWidth / 2, channelY);
	          ctx.font = '12px system-ui, sans-serif';
	          ctx.fillText(normalText, (logicalWidth - totalWidth) / 2 + boldWidth + normalWidth / 2, channelY);

	          // --- Download ---
	          const link = document.createElement('a');
	          const safeName = pollutant.replace(/[^a-z0-9_\-]/gi, '_');
	          link.download = `${safeName}_comparison.png`;
	          link.href = canvas.toDataURL('image/png');
	          document.body.appendChild(link);
	          link.click();
	          link.remove();
	        };
			
      logo.onload = () => {
        try {
          const logoSize = 80;
          ctx.drawImage(logo, logicalWidth - logoSize - 20, 10, logoSize, logoSize);
          finishExport();
        } catch (e) {
          console.warn('Logo failed to draw, continuing without logo:', e);
          finishExport();
        }
      };

      logo.onerror = () => {
        console.warn('Logo failed to load, continuing without logo');
        finishExport();
      };
    };

    img.onerror = (e) => {
      console.error('Failed to load chart image for export', e);
      alert('Sorry ‚Äî failed to generate the PNG from the chart image.');
    };

    // --- Get high-resolution SVG image ---
    if (svgEl) {
      try {
        const origW = parseInt(svgEl.getAttribute('width')) || chartContainer.offsetWidth || 800;
        const origH = parseInt(svgEl.getAttribute('height')) || chartContainer.offsetHeight || 400;
        const exportScale = computeSafeExportScale(origW, origH, Math.max(window.devicePixelRatio || 1, EXPORT_MIN_SCALE));
        const cloned = svgEl.cloneNode(true);
        if (!cloned.getAttribute('viewBox')) cloned.setAttribute('viewBox', `0 0 ${origW} ${origH}`);
        cloned.setAttribute('width', Math.round(origW * exportScale));
        cloned.setAttribute('height', Math.round(origH * exportScale));
        
        pruneYearsFromSVG(cloned, { debug: true });

        let svgString = new XMLSerializer().serializeToString(cloned);
        const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);
        img.src = url;
      } catch (err) {
        console.warn('SVG export failed, falling back to getImageURI()', err);
        img.src = getCleanChartImageURI(chart) || chart.getImageURI();
      }
    } else {
      img.src = getCleanChartImageURI(chart) || chart.getImageURI();
    }

// Return a clean chart image URI by temporarily hiding default 4-digit tick text nodes
// (those not marked with data-custom-year) so chart.getImageURI() won't include them.
function getCleanChartImageURI(chart) {
  try {
    const chartContainer = document.getElementById('chart_div');
    const svg = chartContainer ? chartContainer.querySelector('svg') : null;
    const hidden = [];
    if (svg) {
      const nodes = Array.from(svg.querySelectorAll('text'));
      nodes.forEach(node => {
        const txt = (node.textContent || '').trim();
        if (/^\d{4}$/.test(txt) && !node.closest('[data-custom-year]')) {
          // hide the <text> element (record previous inline display)
          hidden.push({ el: node, prev: node.style.display });
          node.style.display = 'none';
        }
      });
    }
    // synchronous call returning data URI
    const uri = chart.getImageURI();
    // restore
    hidden.forEach(h => { try { h.el.style.display = h.prev || ''; } catch (e) {} });
    return uri;
  } catch (e) {
    console.warn('getCleanChartImageURI failed, falling back to chart.getImageURI():', e);
    try { return chart.getImageURI(); } catch (err) { console.warn('chart.getImageURI() also failed', err); return null; }
  }
}
  });
}
/* ---------------- Initialization ---------------- */
// Parse URL parameters for shared configurations
function parseUrlParameters() {
  const params = new URLSearchParams(window.location.search);
  const result = {};
  
  // Get pollutant ID
  if (params.has('pollutant_id')) {
    result.pollutant_id = params.get('pollutant_id');
  }
  
  // Get group IDs (can be comma-separated)
  if (params.has('group_ids')) {
    const groupIds = params.get('group_ids');
    result.group_ids = groupIds.split(',').map(id => id.trim()).filter(id => id);
  }
  
  // Get year range
  if (params.has('start_year')) {
    result.start_year = params.get('start_year');
  }
  
  if (params.has('end_year')) {
    result.end_year = params.get('end_year');
  }
  
  return result;
}

async function init(){
  try {
    console.log("üîÑ Initializing Supabase data...");
    
    // Track page load
    trackAnalytics('page_load', {
      version: 'v2.1 test (Supabase)',
      load_time: Date.now(),
      screen_resolution: screen.width + 'x' + screen.height,
      viewport: window.innerWidth + 'x' + window.innerHeight
    });
    
    // --- Load all data once ---
    await loadUnits();
    await loadData();
    await loadGroupInfo();

    // --- Populate dropdowns ---
    setupSelectors();

    // Check if this is a shared URL that needs processing
    const urlParams = parseUrlParameters();
    const isSharedUrl = urlParams.pollutant_id || urlParams.group_ids || urlParams.start_year || urlParams.end_year;

    // For normal URLs, do all DOM setup BEFORE showing UI
    if (!isSharedUrl) {
      // Set default pollutant
      const pollutantSelect = document.getElementById("pollutantSelect");
      if (pollutantSelect.querySelector("option[value=\"PM2.5\"]")) {
        pollutantSelect.value = "PM2.5";
      }

      // Add default group selector EARLY (before any UI transitions)
      const firstGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all") || (window.allGroupsList?.[0] || "");
      if (firstGroup) {
        addGroupSelector(firstGroup, false);
      } else {
        addGroupSelector("", true); // Empty placeholder if no groups available
      }

      const revealPromise = revealMainContent();

      setupDownloadButton();
      setupSmoothingToggle();
      setupShareButton();
      setupInteractionTracking();
      document.getElementById("downloadCSVBtn").addEventListener("click", () => exportData("csv"));
      document.getElementById("downloadXLSXBtn").addEventListener("click", () => exportData("xlsx"));

      await revealPromise;
      return; // Skip URL processing for normal URLs
    }

    // --- Process shared URL parameters ---    
    const pollutantSelect = document.getElementById('pollutantSelect');
    
    // Set pollutant from URL or default to PM2.5
    if (urlParams.pollutant_id) {
      // Find pollutant name by ID
      const pollutantData = pollutantsData.find(pd => 
        pd.id === parseInt(urlParams.pollutant_id)
      );
      
      if (pollutantData) {
        const pollutantName = pollutantData.Pollutant || pollutantData.pollutant;
        if (pollutantName) {
          pollutantSelect.value = pollutantName;
          console.log(`üîó Loaded pollutant from URL: ${pollutantName} (ID: ${urlParams.pollutant_id})`);
          
          // Track shared URL usage
          trackAnalytics('shared_url_load', {
            pollutant_id: urlParams.pollutant_id,
            pollutant_name: pollutantName,
            group_ids: urlParams.group_ids || 'none',
            start_year: urlParams.start_year || '',
            end_year: urlParams.end_year || '',
            has_year_range: !!(urlParams.start_year && urlParams.end_year)
          });
        }
      }
    } else {
      // Default behavior
      const pm25 = pollutantSelect.querySelector('option[value="PM2.5"]');
      if (pm25) pollutantSelect.value = "PM2.5";
      else if (pollutantSelect.options.length > 1) pollutantSelect.selectedIndex = 1;
    }

    // Handle group selection from URL or use defaults
    const groupContainer = document.getElementById('groupContainer');
    
    if (urlParams.group_ids && urlParams.group_ids.length > 0) {
      // Load groups from URL parameters
      console.log(`üîó Loading groups from URL: ${urlParams.group_ids.join(', ')}`);
      
      // Clear any existing group selectors
      groupContainer.innerHTML = '';
      
      // Add group selectors for each ID in URL
      urlParams.group_ids.forEach(groupId => {
        const groupData = groupsData.find(gd => gd.id === parseInt(groupId));
        if (groupData) {
          const groupName = groupData.Group_Title || groupData.group_title;
          if (groupName) {
            addGroupSelector(groupName, false);
          }
        }
      });
      
      // If no valid groups were found from IDs, fall back to default
      if (groupContainer.querySelectorAll('select').length === 0) {
        console.warn('üö´ No valid groups found from URL IDs, using default');
        const defaultGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all") || (window.allGroupsList?.[0] || "");
        if (defaultGroup) addGroupSelector(defaultGroup, false);
        else addGroupSelector("", true);
      }
    } else {
      // Default behavior when no URL groups
      let firstGroup = (window.allGroupsList || []).find(g => g.toLowerCase() === "all")
        || (window.allGroupsList?.[0] || "");

      // If group list is empty or doesn't contain "All", fall back to groups discovered in groupedData
      if (!firstGroup) {
        // try groups for selected pollutant first
        const chosenPoll = pollutantSelect.value || window.allPollutants?.[0];
        const groupsForPoll = chosenPoll ? Object.keys(groupedData[chosenPoll] || {}) : [];
        firstGroup = groupsForPoll[0] || (Object.values(groupedData).flatMap(p => Object.keys(p))[0] || "");
      }

      // If still no firstGroup but there's at least one group in window.allGroupsList, use that
      if (!firstGroup && window.allGroupsList && window.allGroupsList.length) {
        firstGroup = window.allGroupsList[0];
      }

      // Add a selector only if there isn't one already
      if (document.querySelectorAll('#groupContainer select').length === 0) {
        if (firstGroup) addGroupSelector(firstGroup, false);
        else addGroupSelector("", true);
      } else {
        // If selector exists but has no selection, try to set it
        const existingSel = document.querySelector('#groupContainer select');
        if (existingSel && !existingSel.value && firstGroup) existingSel.value = firstGroup;
      }
    }
    
    // --- Set year range from URL parameters ---
    const startYearSelect = document.getElementById('startYear');
    const endYearSelect = document.getElementById('endYear');
    
    if (urlParams.start_year && startYearSelect) {
      const startOption = startYearSelect.querySelector(`option[value="${urlParams.start_year}"]`);
      if (startOption) {
        startYearSelect.value = urlParams.start_year;
        console.log(`üîó Set start year from URL: ${urlParams.start_year}`);
      }
    }
    
    if (urlParams.end_year && endYearSelect) {
      const endOption = endYearSelect.querySelector(`option[value="${urlParams.end_year}"]`);
      if (endOption) {
        endYearSelect.value = urlParams.end_year;
        console.log(`üîó Set end year from URL: ${urlParams.end_year}`);
      }
    }

    // --- Chart will be drawn after UI is shown ---



    // === SHOW UI for shared URLs - after URL processing ===
    const revealPromise = revealMainContent();

    setupDownloadButton();
    setupSmoothingToggle();
    setupShareButton();
    setupInteractionTracking();
    document.getElementById("downloadCSVBtn").addEventListener("click", () => exportData("csv"));
    document.getElementById("downloadXLSXBtn").addEventListener("click", () => exportData("xlsx"));

    await revealPromise;
  } catch (err) {
    console.error("‚ùå Initialization failed:", err);
    document.getElementById('loadingOverlay').innerHTML =
      '<div style="color:#900;font-weight:700">Failed to load Supabase data ‚Äî check connection or table names.</div>';
  }

}

function setupInteractionTracking() {
  // Track "How to Use" section interactions
  const howToUseDetails = document.querySelector('details');
  if (howToUseDetails) {
    howToUseDetails.addEventListener('toggle', () => {
      if (howToUseDetails.open) {
        trackAnalytics('ui_interaction', {
          element: 'how_to_use_section',
          action: 'opened'
        });
      }
    });
  }

  // Track "Group Info" section interactions
  const groupInfoDetails = document.querySelectorAll('details')[1]; // Second details element
  if (groupInfoDetails) {
    groupInfoDetails.addEventListener('toggle', () => {
      if (groupInfoDetails.open) {
        trackAnalytics('ui_interaction', {
          element: 'group_info_section',
          action: 'opened'
        });
      }
    });
  }

  // Track smoothing toggle clicks
  const smoothBtn = document.getElementById('toggleSmoothBtn');
  if (smoothBtn) {
    smoothBtn.addEventListener('click', () => {
      trackAnalytics('ui_interaction', {
        element: 'smoothing_toggle',
        action: 'clicked',
        new_state: !smoothLines ? 'enabled' : 'disabled'
      });
    });
  }
}

function setupSmoothingToggle() {
  const btn = document.getElementById('toggleSmoothBtn');
  btn.addEventListener('click', () => {
    smoothLines = !smoothLines;
    btn.textContent = smoothLines ? 'üö´ Disable Smoothing' : '‚úÖ Enable Smoothing';
    updateChart();
  });
}
function exportData(format = 'csv') {
  const pollutant = document.getElementById('pollutantSelect').value;
  const startYear = +document.getElementById('startYear').value;
  const endYear = +document.getElementById('endYear').value;
  const selectedGroups = getSelectedGroups();
  
  console.log('Export debug:', { pollutant, startYear, endYear, selectedGroups, globalHeadersLength: window.globalHeaders?.length });
  
  if (!pollutant || !selectedGroups.length || !(window.globalHeaders?.length)) {
    console.warn('Export validation failed:', { 
      hasPollutant: !!pollutant, 
      hasGroups: selectedGroups.length > 0, 
      hasHeaders: window.globalHeaders?.length > 0 
    });
    alert('Please select a pollutant and at least one group first.');
    return;
  }

  // Track export analytics
  trackAnalytics('data_export', {
    format: format,
    pollutant: pollutant,
    start_year: startYear,
    end_year: endYear,
    groups: selectedGroups,
    groups_count: selectedGroups.length,
    year_range: endYear - startYear + 1,
    filename: pollutant.replace(/[^a-z0-9_\-]/gi, '_') + '_' + startYear + '-' + endYear + '_comparison'
  });

  // Use the global year keys / labels determined earlier
  const yearsAll = window.globalYears || [];
  const yearKeys = window.globalYearKeys || [];
  const startIdx = yearsAll.indexOf(String(startYear));
  const endIdx = yearsAll.indexOf(String(endYear));
  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    alert('Invalid year range.');
    return;
  }
  const years = yearsAll.slice(startIdx, endIdx + 1);
  const keysForYears = yearKeys.slice(startIdx, endIdx + 1);
  const unit = pollutantUnits[pollutant] || '';

  // --- Build rows ---
  const rows = [];
  const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 16);

  // First row: pollutant and unit
  rows.push([`Pollutant: ${pollutant}`, `Unit: ${unit}`]);
  rows.push([]); // spacer row
  // Header row
  rows.push(['Group', ...years]);


  // Data rows - read values by key for robustness
  selectedGroups.forEach(group => {
    const values = keysForYears.map((k) => {
      // look up the data row for this pollutant and group
      const dataRow = groupedData[pollutant] ? groupedData[pollutant][group] : null;
      const raw = dataRow ? dataRow[k] : null;
      return raw ?? '';
    });
    rows.push([group, ...values]);
  });


  rows.push([]); // spacer
  rows.push([`Downloaded on: ${timestamp}`]);

  // --- Generate and download file ---
  const safePollutant = pollutant.replace(/[^a-z0-9_\-]/gi, '_');
  if (format === 'csv') {
    const csvContent = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `${safePollutant}_data.csv`;
    link.click();
  } else if (format === 'xlsx') {
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, 'Data');
    XLSX.writeFile(wb, `${safePollutant}_data.xlsx`);
  }
}

// Generate shareable URL with current configuration
function generateShareUrl() {
  const pollutantSelect = document.getElementById('pollutantSelect');
  const selectedGroups = getSelectedGroups();
  
  if (!pollutantSelect.value || selectedGroups.length === 0) {
    alert('Please select a pollutant and at least one group before sharing.');
    return null;
  }
  
  // Get pollutant ID
  const pollutantData = pollutantsData.find(pd => 
    (pd.Pollutant || pd.pollutant) === pollutantSelect.value
  );
  
  if (!pollutantData) {
    alert('Unable to find pollutant ID for sharing.');
    return null;
  }
  
  // Get group IDs
  const groupIds = [];
  selectedGroups.forEach(groupName => {
    const groupData = groupsData.find(gd => 
      (gd.Group_Title || gd.group_title) === groupName
    );
    if (groupData) {
      groupIds.push(groupData.id);
    }
  });
  
  if (groupIds.length === 0) {
    alert('Unable to find group IDs for sharing.');
    return null;
  }
  
  // Get year selections
  const startYearSelect = document.getElementById('startYear');
  const endYearSelect = document.getElementById('endYear');
  const startYear = startYearSelect ? startYearSelect.value : null;
  const endYear = endYearSelect ? endYearSelect.value : null;
  
  // Build URL with all parameters
  const baseUrl = window.location.origin + window.location.pathname;
  let shareUrl = `${baseUrl}?pollutant_id=${pollutantData.id}&group_ids=${groupIds.join(',')}`;
  
  // Add year parameters if they are set
  if (startYear) {
    shareUrl += `&start_year=${startYear}`;
  }
  if (endYear) {
    shareUrl += `&end_year=${endYear}`;
  }
  
  return shareUrl;
}

// Setup share button functionality
function setupShareButton() {
  const shareBtn = document.getElementById('shareBtn');
  if (!shareBtn) return;
  
  shareBtn.addEventListener('click', () => {
    const shareUrl = generateShareUrl();
    if (!shareUrl) return;
    
    // Track share usage
    trackAnalytics('share_button_click', {
      pollutant: document.getElementById('pollutantSelect').value,
      group_count: getSelectedGroups().length,
      start_year: document.getElementById('startYear')?.value || '',
      end_year: document.getElementById('endYear')?.value || '',
      year_span: (document.getElementById('endYear')?.value && document.getElementById('startYear')?.value) 
        ? (parseInt(document.getElementById('endYear').value) - parseInt(document.getElementById('startYear').value) + 1) 
        : null
    });
    
    // Show share options
    showShareDialog(shareUrl);
  });
}

// Show share dialog with copy and email options
function showShareDialog(shareUrl) {
  const pollutantName = document.getElementById('pollutantSelect').value;
  const selectedGroups = getSelectedGroups();
  const startYear = document.getElementById('startYear')?.value || '';
  const endYear = document.getElementById('endYear')?.value || '';
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  `;
  
  const content = document.createElement('div');
  content.style.cssText = `
    background: white;
    padding: 24px;
    border-radius: 12px;
    max-width: 500px;
    width: 90%;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  `;
  
  const yearRange = (startYear && endYear) ? ` (${startYear}-${endYear})` : '';
  const title = `${pollutantName} - ${selectedGroups.join(', ')}${yearRange}`;
  const description = `View ${pollutantName} emissions data for ${selectedGroups.length === 1 ? selectedGroups[0] : selectedGroups.length + ' groups'}${yearRange ? ` from ${startYear} to ${endYear}` : ''} using the NAEI Multi-Group Pollutant Viewer.`;
  
  content.innerHTML = `
    <h3 style="margin: 0 0 16px 0; color: #333;">üîó Share Chart</h3>
    <p style="margin: 0 0 16px 0; color: #666;">Share this specific chart configuration:</p>
    <p style="margin: 0 0 16px 0; font-weight: 600; color: #000;">${title}</p>
    
    <div style="margin: 16px 0;">
      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Shareable URL:</label>
      <div style="display: flex; gap: 8px;">
   <input type="text" id="shareUrlInput" name="shareUrlInput" value="${shareUrl}" readonly 
     style="flex: 1; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; background: #f9f9f9;">
        <button id="copyUrlBtn" style="padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
          üìã Copy
        </button>
      </div>
    </div>
    
    <div style="margin: 16px 0;">
      <label style="display: flex; align-items: center; margin-bottom: 12px; cursor: pointer;">
  <input type="checkbox" id="includeImageCheckbox" name="includeImageCheckbox" style="margin-right: 8px;">
        <span style="font-weight: 600;">üñºÔ∏è Copy chart image to clipboard for pasting into email</span>
      </label>
      
      <button id="emailShareBtn" style="padding: 12px 20px; background: #2196F3; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; margin-right: 8px;">
        üìß Email Link
      </button>
      <button id="closeShareBtn" style="padding: 12px 20px; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
        ‚ùå Close
      </button>
    </div>
  `;
  
  dialog.appendChild(content);
  document.body.appendChild(dialog);
  
  // Copy URL functionality
  content.querySelector('#copyUrlBtn').addEventListener('click', async () => {
    const input = content.querySelector('#shareUrlInput');
    try {
      await navigator.clipboard.writeText(shareUrl);
      const btn = content.querySelector('#copyUrlBtn');
      btn.textContent = '‚úÖ Copied!';
      btn.style.background = '#4CAF50';
      
      trackAnalytics('share_url_copied', {
        pollutant: pollutantName,
        group_count: selectedGroups.length,
        start_year: startYear,
        end_year: endYear,
        has_year_range: !!(startYear && endYear)
      });
      
      setTimeout(() => {
        btn.textContent = 'üìã Copy';
        btn.style.background = '#4CAF50';
      }, 2000);
    } catch (err) {
      // Fallback for older browsers
      input.select();
      document.execCommand('copy');
      alert('URL copied to clipboard!');
    }
  });
  
  // Email sharing functionality
  content.querySelector('#emailShareBtn').addEventListener('click', async () => {
    const includeImage = content.querySelector('#includeImageCheckbox').checked;
    
    // Create detailed email content
    const subject = encodeURIComponent(`NAEI Emissions Data: ${pollutantName} ${yearRange}`);
    
    let emailBody = `I'm sharing NAEI emissions data for ${pollutantName}${yearRange ? ` from ${startYear} to ${endYear}` : ''}.\n\n`;
    emailBody += `Groups included:\n`;
    selectedGroups.forEach((group, index) => {
      emailBody += `${index + 1}. ${group}\n`;
    });
    emailBody += `\n`;
    
    if (includeImage) {
      try {
        // Generate comprehensive chart image (same as PNG download)
        const chartImageData = await generateChartImage();
        
        // Copy to clipboard
        if (navigator.clipboard && navigator.clipboard.write && typeof ClipboardItem !== 'undefined') {
          const blob = dataURLtoBlob(chartImageData);
          const clipboardItem = new ClipboardItem({ 'image/png': blob });
          await navigator.clipboard.write([clipboardItem]);
          
          emailBody += `üñºÔ∏è Chart Image:\n`;
          emailBody += `The complete chart image (including title, legend, and CIC logo) has been copied to your clipboard.\n`;
          emailBody += `You can now paste it directly into your email.\n\n`;
        } else {
          emailBody += `üìã Chart Image:\n`;
          emailBody += `Your browser doesn't support automatic clipboard copying.\n`;
          emailBody += `Please use the "‚¨áÔ∏è Download Chart as PNG" button to get the chart image.\n\n`;
        }
        
      } catch (error) {
        console.warn('Could not generate chart image:', error);
        emailBody += `üñºÔ∏è Chart Image:\n`;
        emailBody += `Chart image could not be generated automatically.\n`;
        emailBody += `Please use the "‚¨áÔ∏è Download Chart as PNG" button to get the chart image.\n\n`;
      }
    }
    
    emailBody += `Interactive chart: ${shareUrl}\n\n`;
    emailBody += `Generated by the Chronic Illness Channel NAEI Multi-Group Pollutant Viewer\n`;
    emailBody += `Youtube Channel: http://youtube.com/@chronicillnesschannel`;
    
    const body = encodeURIComponent(emailBody);
    const mailto = `mailto:?subject=${subject}&body=${body}`;
    
    trackAnalytics('share_email_opened', {
      pollutant: pollutantName,
      group_count: selectedGroups.length,
      start_year: startYear,
      end_year: endYear,
      has_year_range: !!(startYear && endYear),
      include_image: includeImage
    });
    
    window.location.href = mailto;
  });
  
  // Close dialog
  const closeDialog = () => {
    document.body.removeChild(dialog);
  };
  
  content.querySelector('#closeShareBtn').addEventListener('click', closeDialog);
  dialog.addEventListener('click', (e) => {
    if (e.target === dialog) closeDialog();
  });
  
  // Focus the URL input for easy copying
  setTimeout(() => {
    content.querySelector('#shareUrlInput').select();
  }, 100);
}

// Generate comprehensive chart image for email sharing (same as PNG download)
async function generateChartImage() {
  return new Promise((resolve, reject) => {
    try {
      const pollutant = document.getElementById('pollutantSelect').value;
      if (!chart || !pollutant) {
        reject(new Error('Chart or pollutant not available'));
        return;
      }

      const unit = pollutantUnits[pollutant] || "";

    // Render chart SVG at higher pixel density for better quality in generated images
    const chartContainer = document.getElementById('chart_div');
    const svgEl = chartContainer ? chartContainer.querySelector('svg') : null;
      let img = new Image();
      img.crossOrigin = 'anonymous';

      if (svgEl) {
        try {
          const origW = parseInt(svgEl.getAttribute('width')) || chartContainer.offsetWidth || 800;
          const origH = parseInt(svgEl.getAttribute('height')) || chartContainer.offsetHeight || 400;
          const exportScale = computeSafeExportScale(origW, origH, Math.max(window.devicePixelRatio || 1, EXPORT_MIN_SCALE));
          const cloned = svgEl.cloneNode(true);
          if (!cloned.getAttribute('viewBox')) cloned.setAttribute('viewBox', `0 0 ${origW} ${origH}`);
          cloned.setAttribute('width', Math.round(origW * exportScale));
          cloned.setAttribute('height', Math.round(origH * exportScale));
          // Remove default small year tick labels from the cloned SVG so only our custom labels remain
          try {
            // Centralized pruning helper removes default 4-digit tick labels
            pruneYearsFromSVG(cloned, { debug: true });
          } catch (e) {
            console.warn('Could not prune default year labels from cloned SVG (email export):', e);
          }
          let svgString = new XMLSerializer().serializeToString(cloned);
          try {
            // Final textual pruning to remove any remaining 4-digit year labels
            // but DO NOT remove labels that are explicitly marked data-custom-year.
            svgString = svgString.replace(/<text(?![^>]*data-custom-year)[^>]*>\s*\d{4}\s*<\/text>/g, '');
            svgString = svgString.replace(/<text(?![^>]*data-custom-year)[^>]*>[\s\S]*?<tspan[^>]*>\s*\d{4}\s*<\/tspan>[\s\S]*?<\/text>/g, '');
          } catch (e) { console.warn('Final SVG string pruning failed (email export):', e); }
          const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(svgBlob);
          img.src = url;
        } catch (err) {
          console.warn('SVG export failed, falling back to getImageURI()', err);
          img = new Image();
          img.crossOrigin = 'anonymous';
          try {
            const liveSvg = chartContainer ? chartContainer.querySelector('svg') : null;
            if (liveSvg) {
              try { pruneYearsFromSVG(liveSvg, { debug: false }); } catch (e) { console.warn('pruneYearsFromSVG failed on liveSvg', e); }
            }
          } catch (e) { console.warn('Failed to prune live SVG ticks before fallback:', e); }
          img.src = getCleanChartImageURI(chart) || chart.getImageURI();
          try {
            window.__export_debug = window.__export_debug || {};
            window.__export_debug.last = window.__export_debug.last || {};
            window.__export_debug.last.method = 'bitmap';
          } catch (e) { /* ignore */ }
        }
      } else {
        try {
          const liveSvg = chartContainer ? chartContainer.querySelector('svg') : null;
          if (liveSvg) {
            try { pruneYearsFromSVG(liveSvg, { debug: false }); } catch (e) { console.warn('pruneYearsFromSVG failed on liveSvg', e); }
          }
        } catch (e) { console.warn('Failed to prune live SVG ticks before fallback:', e); }
  img.src = getCleanChartImageURI(chart) || chart.getImageURI();
      }

      img.onload = () => {
        try {
          // --- Measure legend for layout ---
          const legendClone = document.getElementById('customLegend').cloneNode(true);
          legendClone.style.position = 'absolute';
          legendClone.style.visibility = 'hidden';
          const logoSize = 80;
          const padding = 20;
          const maxLegendWidth = Math.max(100, img.width - padding * 2 - logoSize - 20);
          legendClone.style.width = Math.min(800, maxLegendWidth) + 'px';
          document.body.appendChild(legendClone);
          const legendHeight = legendClone.offsetHeight + 10;
          document.body.removeChild(legendClone);

          const titleHeight = 30;
          const footerHeight = 40;

          // --- Determine output size ---
          const unscaledWidth = img.width + padding * 2;
          const unscaledHeight = img.height + titleHeight + legendHeight + footerHeight + padding * 3;

          // --- Create canvas ---
          const canvas = document.createElement('canvas');
          canvas.width = unscaledWidth;
          canvas.height = unscaledHeight;
          const ctx = canvas.getContext('2d');

          // --- Background ---
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, unscaledWidth, unscaledHeight);

          // --- Title ---
          ctx.font = 'bold 18px system-ui, sans-serif';
          ctx.fillStyle = '#000000';
          ctx.textAlign = 'center';
          ctx.fillText(
            `${pollutant}${unit ? " (" + unit + ")" : ""}`,
            unscaledWidth / 2,
            padding + 15
          );

          // --- Legend ---
          const legendDiv = document.getElementById('customLegend');
          const items = [...legendDiv.querySelectorAll('span')];
          let legendY = padding + 35;
          const legendRowHeight = 22;
          const maxW = unscaledWidth - padding * 2;
          const rowItems = [];
          let row = [], rowW = 0;

          items.forEach((it) => {
            const dot = it.querySelector('span');
            if (!dot) return;
            const text = it.textContent.trim();
            ctx.font = '600 14px system-ui, sans-serif';
            const textW = ctx.measureText(text).width;
            const w = textW + 40;
            if (rowW + w > maxW && row.length) {
              rowItems.push({ row, rowW });
              row = [];
              rowW = 0;
            }
            row.push({ dotColor: dot.style.backgroundColor, text });
            rowW += w;
          });

          if (row.length) rowItems.push({ row, rowW });

          rowItems.forEach(({ row, rowW }) => {
            let x = (unscaledWidth - rowW) / 2;
            row.forEach(({ dotColor, text }) => {
              const faded = text.includes('(No data available)');
              ctx.globalAlpha = faded ? 0.4 : 1.0;
              ctx.beginPath();
              ctx.arc(x + 6, legendY - 5, 6, 0, 2 * Math.PI);
              ctx.fillStyle = dotColor;
              ctx.fill();
              ctx.font = '600 14px system-ui, sans-serif';
              ctx.fillStyle = '#000000';
              ctx.textAlign = 'left';
              ctx.fillText(text, x + 18, legendY);
              ctx.globalAlpha = 1.0;
              x += ctx.measureText(text).width + 40;
            });
            legendY += legendRowHeight;
          });

          // --- Chart image ---
          // Draw rasterized chart image without browser smoothing for crisper lines
          try {
            const prevSmoothing = typeof ctx.imageSmoothingEnabled !== 'undefined' ? ctx.imageSmoothingEnabled : null;
            try { ctx.imageSmoothingEnabled = false; } catch (e) {}
            try { ctx.webkitImageSmoothingEnabled = false; } catch (e) {}
            try { ctx.mozImageSmoothingEnabled = false; } catch (e) {}
            ctx.drawImage(img, padding, legendY + 10);
            if (prevSmoothing !== null) try { ctx.imageSmoothingEnabled = prevSmoothing; } catch (e) {}
          } catch (eS) {
            ctx.drawImage(img, padding, legendY + 10);
          }
          // Erase any small default tick labels baked into the raster image.
          try {
            const chartContainer = document.getElementById('chart_div');
            const chartLayout = chart.getChartLayoutInterface && chart.getChartLayoutInterface();
            if (chartLayout && chartContainer) {
              const chartArea = chartLayout.getChartAreaBoundingBox();
              const tickY = chartArea.top + chartArea.height + 20;
              const tickHeight = 18;
              const containerW = chartContainer.offsetWidth || 1;
              const containerH = chartContainer.offsetHeight || 1;
              const scaleX = (img.width || containerW) / containerW;
              const scaleY = (img.height || containerH) / containerH;
              const rectX = padding + (chartArea.left || 0) * scaleX;
              const rectY = legendY + 10 + tickY * scaleY - tickHeight / 2;
              const rectW = (chartArea.width || containerW) * scaleX;
              const rectH = tickHeight;
              ctx.save();
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(rectX, rectY, rectW, rectH);
              ctx.restore();
            } else {
              ctx.save();
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(padding, legendY + 10 + (img.height || 0) - 30, img.width || 0, 40);
              ctx.restore();
            }
          } catch (e) {
            console.warn('Could not erase small tick area on generated image:', e);
          }

          // --- Logo and footer ---
          const logo = new Image();
          logo.crossOrigin = 'anonymous';
          logo.src = 'CIC - Square - Border - Words - Alpha 360x360.png';

          const finishGeneration = () => {
            const footerText = "¬© Crown 2025 copyright Defra & DESNZ via naei.energysecurity.gov.uk licensed under the Open Government Licence (OGL).";
            const channelText = "Youtube Channel: youtube.com/@chronicillnesschannel";
            
            ctx.font = '12px system-ui, sans-serif';
            ctx.fillStyle = '#555';
            ctx.textAlign = 'center';
            ctx.fillText(footerText, unscaledWidth / 2, legendY + img.height + 20);
            
            // Draw YouTube channel with bold label
            const channelY = legendY + img.height + 35;
            const boldText = "Youtube Channel: ";
            const normalText = "youtube.com/@chronicillnesschannel";
            
            // Measure text widths for positioning
            ctx.font = 'bold 12px system-ui, sans-serif';
            const boldWidth = ctx.measureText(boldText).width;
            ctx.font = '12px system-ui, sans-serif';
            const normalWidth = ctx.measureText(normalText).width;
            const totalWidth = boldWidth + normalWidth;
            
            // Draw bold part
            ctx.font = 'bold 12px system-ui, sans-serif';
            ctx.fillText(boldText, (unscaledWidth - totalWidth) / 2 + boldWidth / 2, channelY);
            
            // Draw normal part
            ctx.font = '12px system-ui, sans-serif';
            ctx.fillText(normalText, (unscaledWidth - totalWidth) / 2 + boldWidth + normalWidth / 2, channelY);
            
            const dataURL = canvas.toDataURL('image/png');
            resolve(dataURL);
          };

          logo.onload = () => {
            try {
              const logoSize = 80;
              ctx.drawImage(logo, unscaledWidth - logoSize - 20, 10, logoSize, logoSize);
              finishGeneration();
            } catch (e) {
              console.warn('Logo failed to draw, continuing without logo:', e);
              finishGeneration();
            }
          };

          logo.onerror = () => {
            console.warn('Logo failed to load, continuing without logo');
            finishGeneration();
          };

        } catch (error) {
          reject(error);
        }
      };

      img.onerror = (e) => {
        reject(new Error('Failed to load chart image for generation'));
      };
    } catch (error) {
      reject(error);
    }
  });
}

// Convert data URL to Blob for clipboard
function dataURLtoBlob(dataURL) {
  const arr = dataURL.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
}

async function loadGroupInfo() {
  try {
    let groupRows = [];
    let nfrRows = [];

    if (supabase) {
      const { data: supabaseGroups, error: groupError } = await supabase
        .from('NAEI_global_t_Group')
        .select('id,Group_Title,SourceName,ActivityName,NFRCode');

      if (groupError) {
        console.warn('Failed to load group info from Supabase:', groupError);
      } else {
        groupRows = supabaseGroups || [];
      }

      try {
        const { data: supabaseNfr, error: nfrError } = await supabase
          .from('NAEI_global_t_NFRCode')
          .select('*');

        if (nfrError) {
          console.warn('Failed to load NFR code descriptions from Supabase:', nfrError);
        } else {
          nfrRows = supabaseNfr || [];
        }
      } catch (nfrErr) {
        console.warn('Failed to load NFR code descriptions from Supabase:', nfrErr);
      }
    } else {
      console.warn('Supabase client unavailable; falling back to cached group rows.');
    }

    if (!groupRows.length && groupsData && groupsData.length) {
      groupRows = groupsData;
    }

    if (!groupRows.length) {
      throw new Error('No group information available from Supabase or cached data.');
    }

    const nfrMap = {};
    nfrRows.forEach(nfr => {
      const code = nfr?.NFRCode || nfr?.nfrcode || nfr?.nfr_code;
      const description = nfr?.Description || nfr?.description;
      if (code && description) {
        nfrMap[code] = description;
      }
    });

    const groupMap = {};

    groupRows.forEach(row => {
      const groupTitle = row?.Group_Title || row?.group_title || row?.Group || row?.group;
      const sourceName = row?.SourceName || row?.source_name || row?.Source || row?.source;
      const activityName = row?.ActivityName || row?.activity_name || row?.Activity || row?.activity;
      const nfrCodeField = row?.NFRCode || row?.nfrcode || row?.nfr_code;

      if (!groupTitle) return;

      if (!groupMap[groupTitle]) {
        groupMap[groupTitle] = {
          name: groupTitle,
          sources: new Set(),
          activities: new Set(),
          nfrCodes: new Set()
        };
      }

      if (sourceName) {
        groupMap[groupTitle].sources.add(sourceName);
      }

      if (activityName) {
        groupMap[groupTitle].activities.add(activityName);
      }

      if (nfrCodeField) {
        nfrCodeField
          .split(/[;,]/)
          .map(code => code.trim())
          .filter(Boolean)
          .forEach(code => groupMap[groupTitle].nfrCodes.add(code));
      }
    });

    const groups = Object.values(groupMap)
      .map(g => ({
        name: g.name,
        sources: Array.from(g.sources).sort(),
        activities: Array.from(g.activities).sort(),
        nfrCodes: Array.from(g.nfrCodes).sort()
      }))
      .sort((a, b) => {
        if (a.name.toLowerCase() === 'all') return -1;
        if (b.name.toLowerCase() === 'all') return 1;
        return a.name.localeCompare(b.name);
      });

    if (!groups.length) {
      throw new Error('Group information could not be aggregated.');
    }

    let html = `
      <table id="groupTable" style="border-collapse:collapse;width:100%;font-family:inherit;font-size:14px;color:#000;">
        <thead>
          <tr style="background:#d0d0d0;">
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:25%;">Group Name</th>
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:40%;">Sources</th>
            <th style="border:1px solid #444;padding:8px;text-align:left;vertical-align:top;width:35%;">Fuel Types (Activity in NAEI data)</th>
          </tr>
        </thead>
        <tbody>
    `;

    groups.forEach(g => {
        let sourcesHTML = '';
        // Filter NFR codes to only valid ones
        const validNfrCodes = g.nfrCodes.filter(code => code && code !== 'NULL' && code !== '' && code !== null);
        if (validNfrCodes.length) {
          sourcesHTML += `<span style="text-decoration:underline;font-weight:600;display:block;margin-bottom:4px;">All Sources from the following NFR Code categories:</span>`;
          sourcesHTML += `<div style="white-space:pre-line;">`;
          validNfrCodes.forEach(code => {
            const description = nfrMap[code];
            if (description && description !== 'NULL') {
              sourcesHTML += `${code}: ${description}\n`;
            } else {
              sourcesHTML += `${code}\n`;
            }
          });
          sourcesHTML += `</div>`;
        } else {
          const validSources = g.sources.filter(s => s != null && s !== '' && s !== 'NULL');
          sourcesHTML = validSources.length ? validSources.join('\n') : 'All Sources';
        }

  const validActivities = g.activities.filter(a => a != null && a !== '' && a !== 'NULL');
  const activitiesText = validActivities.length ? validActivities.join('\n') : 'All Fuel Types';

      html += `
        <tr style="border:1px solid #444;">
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${g.name}</td>
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${sourcesHTML}</td>
          <td style="border:1px solid #444;padding:8px;white-space:pre-line;font-family:inherit;">${activitiesText}</td>
        </tr>
      `;
    });

    html += '</tbody></table>';

    const container = document.getElementById('group-info');
    container.style.fontFamily = 'system-ui, sans-serif';
    container.style.fontSize = '14px';
    container.style.color = '#000';
    container.innerHTML = html;

    console.log(`Rendered group info for ${groups.length} groups (Supabase rows: ${groupRows.length}).`);
  } catch (err) {
    console.error('Error loading group info:', err);
    document.getElementById('group-info').innerHTML =
      "<p class='text-red-600'>‚ö†Ô∏è Could not load group or NFRCodes information.</p>";
  }
}
document.addEventListener('DOMContentLoaded', () => google.charts.setOnLoadCallback(init));

// Separate, non-invasive clean export: render an offscreen chart with no hAxis labels
// and compose a high-quality PNG. This does not modify the visible chart or existing
// export pipeline ‚Äî it only runs when the user clicks the `#downloadCleanBtn` button.
document.addEventListener('DOMContentLoaded', () => {
  const cleanBtn = document.getElementById('downloadCleanBtn');
  if (!cleanBtn) return;
  cleanBtn.addEventListener('click', async () => {
    try {
      const pollutant = document.getElementById('pollutantSelect').value;
      if (!chart || !pollutant) return alert('Chart not ready');

      const selectedGroups = getSelectedGroups();
      const startYear = +document.getElementById('startYear').value;
      const endYear = +document.getElementById('endYear').value;
      const unit = pollutantUnits[pollutant] || '';

      // compute offscreen pixel size (match exportScale used elsewhere)
      const chartContainer = document.getElementById('chart_div');
      const exportScale = computeSafeExportScale(
        (chartContainer ? chartContainer.offsetWidth : 800),
        (chartContainer ? chartContainer.offsetHeight : 400),
        Math.max(window.devicePixelRatio || 1, EXPORT_MIN_SCALE)
      );
      const offscreenW = Math.round((chartContainer ? chartContainer.offsetWidth : 800) * exportScale);
      const offscreenH = Math.round((chartContainer ? chartContainer.offsetHeight : 400) * exportScale);

      // Build an offscreen chart and get its bitmap URI
      const offscreenResult = await (function getOffscreenURI() {
        return new Promise((resolve, reject) => {
          try {
            const yearsAll = window.globalYears || [];
            const yearKeys = window.globalYearKeys || [];
            const startIdx = yearsAll.indexOf(String(startYear));
            const endIdx = yearsAll.indexOf(String(endYear));
            const years = (startIdx !== -1 && endIdx !== -1 && endIdx >= startIdx)
              ? yearsAll.slice(startIdx, endIdx + 1)
              : yearsAll.slice();
            const keysForYears = yearKeys.slice(startIdx, endIdx + 1);

            const chartRows = years.map((y, rowIdx) => {
              const row = [y];
              const key = keysForYears[rowIdx];
              selectedGroups.forEach(g => {
                const dataRow = groupedData[pollutant]?.[g];
                const raw = dataRow ? dataRow[key] : null;
                const val = (raw === null || raw === undefined) ? null : parseFloat(raw);
                row.push(Number.isNaN(val) ? null : val);
              });
              return row;
            });

            const dataTable = new google.visualization.DataTable();
            dataTable.addColumn('string', 'Year');
            selectedGroups.forEach(g => dataTable.addColumn('number', g));
            dataTable.addRows(chartRows);

            // Match on-screen chart appearance: use the same series colors and left margin
            const colors = selectedGroups.map(g => getColorForGroup ? getColorForGroup(g) : null);
            const seriesOptions = {};
            selectedGroups.forEach((g, i) => { seriesOptions[i] = { color: colors[i] || undefined, lineWidth: 3, pointSize: 4 }; });
            // Compute left margin based on max value so label widths match the visible chart
            const maxValue = Math.max(...chartRows.flatMap(r => r.slice(1).filter(v => typeof v === 'number')));
            const labelLength = maxValue ? maxValue.toLocaleString().length : 3;
            const leftMargin = Math.min(100, Math.max(60, labelLength * 10));
            const options = {
              title: '',
              width: offscreenW,
              height: offscreenH,
              legend: 'none',
              hAxis: { textPosition: 'none', gridlines: { color: '#e0e0e0' }, baselineColor: '#666' },
              vAxis: { viewWindow: { min: 0 } },
              series: seriesOptions,
              curveType: (window.__smoothLinesEnabled ? 'function' : 'none'),
              lineWidth: 3,
              pointSize: 4,
              chartArea: { top: 20, left: leftMargin, right: 10, bottom: 60, height: '70%' }
            };

            const wrapper = document.createElement('div');
            wrapper.style.position = 'absolute';
            wrapper.style.left = '-9999px';
            wrapper.style.top = '0';
            wrapper.style.width = offscreenW + 'px';
            wrapper.style.height = offscreenH + 'px';
            document.body.appendChild(wrapper);

            const tempChart = new google.visualization.LineChart(wrapper);
            google.visualization.events.addListener(tempChart, 'ready', () => {
              try {
                const u = tempChart.getImageURI();
                // Compute label positions using the offscreen chart layout so they align
                // with the offscreen bitmap exactly.
                let labels = [];
                try {
                  const layout = tempChart.getChartLayoutInterface();
                  const chartArea = layout.getChartAreaBoundingBox();
                  const yearsAll = window.globalYears || [];
                  const startIdx = yearsAll.indexOf(String(startYear));
                  const endIdx = yearsAll.indexOf(String(endYear));
                  const years = (startIdx !== -1 && endIdx !== -1 && endIdx >= startIdx)
                    ? yearsAll.slice(startIdx, endIdx + 1)
                    : yearsAll.slice();
                  const labelsToShow = calculateYearTicks(years, chartArea.width || (chartContainer.offsetWidth || 300));
                  labels = labelsToShow.map(year => {
                    const yearIndex = years.indexOf(year);
                    if (yearIndex === -1) return null;
                    const x = layout.getXLocation(yearIndex);
                    const y = chartArea.top + chartArea.height + 20; // same baseline logic used elsewhere
                    return { year: year, x: x, y: y };
                  }).filter(Boolean);
                } catch (e) {
                  console.warn('Could not compute offscreen label positions', e);
                }

                setTimeout(() => { try { wrapper.remove(); } catch (e) {} }, 50);
                resolve({ uri: u, labels: labels, width: offscreenW, height: offscreenH });
              } catch (e) { try { wrapper.remove(); } catch (er) {} reject(e); }
            });
            tempChart.draw(dataTable, options);
          } catch (err) { reject(err); }
        });
      })();

      if (!offscreenResult || !offscreenResult.uri) return alert('Could not create clean export image');

      // Compose final PNG from offscreen bitmap and use the returned offscreen label positions
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        try {
          const padding = 20;
          const titleHeight = 30;
          const footerHeight = 40;
          const unscaledWidth = img.width + padding * 2;
          const unscaledHeight = img.height + titleHeight + footerHeight + padding * 3 + 60; // include legend space

          // Scale for print quality (A4 300dpi target)
          const targetWidth = 3508;
          const scale = Math.max(window.devicePixelRatio || 1, targetWidth / unscaledWidth);
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(unscaledWidth * scale);
          canvas.height = Math.round(unscaledHeight * scale);
          const ctx = canvas.getContext('2d');
          ctx.scale(scale, scale);

          // Background and title
          ctx.fillStyle = '#fff'; ctx.fillRect(0,0,unscaledWidth,unscaledHeight);
          ctx.font = 'bold 18px system-ui, sans-serif'; ctx.fillStyle = '#000'; ctx.textAlign = 'center';
          ctx.fillText(`${pollutant}${unit ? ' ('+unit+')' : ''}`, unscaledWidth/2, padding+15);

          // Draw the offscreen chart image (disable smoothing for crisper lines)
          const legendY = padding + 35;
          try {
            const prevSmoothing = typeof ctx.imageSmoothingEnabled !== 'undefined' ? ctx.imageSmoothingEnabled : null;
            try { ctx.imageSmoothingEnabled = false; } catch (e) {}
            try { ctx.webkitImageSmoothingEnabled = false; } catch (e) {}
            try { ctx.mozImageSmoothingEnabled = false; } catch (e) {}
            ctx.drawImage(img, padding, legendY + 10, img.width, img.height);
            if (prevSmoothing !== null) try { ctx.imageSmoothingEnabled = prevSmoothing; } catch (e) {}
          } catch (eS) {
            ctx.drawImage(img, padding, legendY + 10, img.width, img.height);
          }

          // Draw logo (if available)
          const logo = new Image(); logo.crossOrigin = 'anonymous';
          logo.onload = () => { try { const logoSize = 80; ctx.drawImage(logo, unscaledWidth - logoSize - 20, 10, logoSize, logoSize); } catch(e){}; finalize(); };
          logo.onerror = () => finalize();
          logo.src = 'CIC - Square - Border - Words - Alpha 360x360.png';

          function finalize() {
            // Draw footer
            ctx.font = '12px system-ui, sans-serif'; ctx.fillStyle = '#555'; ctx.textAlign = 'center';
            const footerText = "¬© Crown 2025 copyright Defra & DESNZ via naei.energysecurity.gov.uk licensed under the Open Government Licence (OGL).";
            ctx.fillText(footerText, unscaledWidth/2, legendY + 10 + img.height + 20);

            // Draw larger year labels on top using offscreen chart's computed positions
            try {
              const labels = offscreenResult.labels || [];
              if (labels && labels.length) {
                ctx.fillStyle = '#333';
                ctx.font = '600 16px system-ui, Arial, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'alphabetic';
                labels.forEach(lp => {
                  const xOnImage = padding + (lp.x || 0);
                  const yOnImage = legendY + 10 + (lp.y || 0);
                  ctx.fillText(String(lp.year), xOnImage, yOnImage);
                });
              }
            } catch (e) { console.warn('Could not draw top labels for clean export', e); }

            // Trigger download
            const link = document.createElement('a');
            link.download = `${pollutant.replace(/[^a-z0-9_\-]/gi,'_')}_clean.png`;
            link.href = canvas.toDataURL('image/png');
            document.body.appendChild(link); link.click(); link.remove();
          }

        } catch (err) { console.error('Clean export failed', err); alert('Clean export failed: '+String(err)); }
      };
      img.onerror = (e) => { console.error('Failed to load offscreen image', e); alert('Failed to load offscreen image for export'); };
      // Use the URI returned by the offscreen renderer. Previous code referenced an undefined
      // `uri` variable which caused a ReferenceError.
      if (offscreenResult && offscreenResult.uri) {
        img.src = offscreenResult.uri;
      } else {
        console.error('Download clean PNG: offscreenResult.uri missing', offscreenResult);
        alert('Clean export failed: missing image data');
      }

    } catch (err) {
      console.error('Download clean PNG failed', err);
      alert('Could not create clean PNG: ' + String(err));
    }
  });
});
</script>
</body>
</html>